ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"user.cpp"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text._Z41__static_initialization_and_destruction_0ii,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.code	16
  21              		.thumb_func
  23              	_Z41__static_initialization_and_destruction_0ii:
  24              		.fnstart
  25              	.LVL0:
  26              	.LFB67:
  27              		.file 1 "Src/user.cpp"
   1:Src/user.cpp  **** #include <cstring>
   2:Src/user.cpp  **** #include "common_inc.h"
   3:Src/user.cpp  **** #include "configurations.h"
   4:Src/user.cpp  **** 
   5:Src/user.cpp  **** Motor motor;
   6:Src/user.cpp  **** BoardConfig_t boardConfig;
   7:Src/user.cpp  **** 
   8:Src/user.cpp  **** 
   9:Src/user.cpp  **** /* Default Entry -------------------------------------------------------*/
  10:Src/user.cpp  **** void Main()
  11:Src/user.cpp  **** {
  12:Src/user.cpp  ****     // Read data from Flash
  13:Src/user.cpp  ****     EEPROM eeprom;
  14:Src/user.cpp  ****     eeprom.get(0, boardConfig);
  15:Src/user.cpp  ****     if (boardConfig.configStatus != CONFIG_OK) // use default settings
  16:Src/user.cpp  ****     {
  17:Src/user.cpp  ****         boardConfig = BoardConfig_t{
  18:Src/user.cpp  ****             .configStatus = CONFIG_OK,
  19:Src/user.cpp  ****             .nodeId = 12, // 7bit address, has to be even number
  20:Src/user.cpp  ****             .initPos = 90,
  21:Src/user.cpp  ****             .toqueLimit =  0.5,
  22:Src/user.cpp  ****             .velocityLimit=0,
  23:Src/user.cpp  ****             .adcValAtAngleMin=250,
  24:Src/user.cpp  ****             .adcValAtAngleMax=3000,
  25:Src/user.cpp  ****             .mechanicalAngleMin=0,
  26:Src/user.cpp  ****             .mechanicalAngleMax=180,
  27:Src/user.cpp  ****             .dceKp = 10,
  28:Src/user.cpp  ****             .dceKv = 0,
  29:Src/user.cpp  ****             .dceKi = 0,
  30:Src/user.cpp  ****             .dceKd = 50,
  31:Src/user.cpp  ****             .enableMotorOnBoot=false
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 2


  32:Src/user.cpp  ****         };
  33:Src/user.cpp  ****         eeprom.put(0, boardConfig);
  34:Src/user.cpp  ****     }
  35:Src/user.cpp  ****     motor.SetTorqueLimit(boardConfig.toqueLimit);
  36:Src/user.cpp  ****     motor.mechanicalAngleMin = boardConfig.mechanicalAngleMin;
  37:Src/user.cpp  ****     motor.mechanicalAngleMax = boardConfig.mechanicalAngleMax;
  38:Src/user.cpp  ****     motor.adcValAtAngleMin = boardConfig.adcValAtAngleMin;
  39:Src/user.cpp  ****     motor.adcValAtAngleMax = boardConfig.adcValAtAngleMax;
  40:Src/user.cpp  ****     motor.dce.kp = boardConfig.dceKp;
  41:Src/user.cpp  ****     motor.dce.ki = boardConfig.dceKi;
  42:Src/user.cpp  ****     motor.dce.kv = boardConfig.dceKv;
  43:Src/user.cpp  ****     motor.dce.kd = boardConfig.dceKd;
  44:Src/user.cpp  ****     motor.dce.setPointPos = boardConfig.initPos;
  45:Src/user.cpp  ****     motor.SetEnable(boardConfig.enableMotorOnBoot);
  46:Src/user.cpp  ****     // Init PWM
  47:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  48:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
  49:Src/user.cpp  ****     __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 0);
  50:Src/user.cpp  ****     __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, 0);
  51:Src/user.cpp  **** 
  52:Src/user.cpp  ****     // Start receive data
  53:Src/user.cpp  ****     MY_I2C1_Init(boardConfig.nodeId);
  54:Src/user.cpp  ****     HAL_Delay(10);
  55:Src/user.cpp  ****     HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
  56:Src/user.cpp  **** 
  57:Src/user.cpp  ****     // Start control loop at 200Hz
  58:Src/user.cpp  ****     HAL_TIM_Base_Start_IT(&htim14);
  59:Src/user.cpp  **** 
  60:Src/user.cpp  **** 
  61:Src/user.cpp  ****     while (1)
  62:Src/user.cpp  ****     {
  63:Src/user.cpp  ****         if (boardConfig.configStatus == CONFIG_COMMIT)
  64:Src/user.cpp  ****         {
  65:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_OK;
  66:Src/user.cpp  ****             eeprom.put(0, boardConfig);
  67:Src/user.cpp  ****         } else if (boardConfig.configStatus == CONFIG_RESTORE)
  68:Src/user.cpp  ****         {
  69:Src/user.cpp  ****             eeprom.put(0, boardConfig);
  70:Src/user.cpp  ****             NVIC_SystemReset();
  71:Src/user.cpp  ****         }
  72:Src/user.cpp  ****     /* for debug */
  73:Src/user.cpp  ****        //LL_GPIO_TogglePin(GPIOA,GPIO_PIN_1);
  74:Src/user.cpp  ****     }
  75:Src/user.cpp  **** }
  76:Src/user.cpp  **** 
  77:Src/user.cpp  **** 
  78:Src/user.cpp  **** /* Callbacks -------------------------------------------------------*/
  79:Src/user.cpp  **** // void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
  80:Src/user.cpp  **** // {
  81:Src/user.cpp  **** 
  82:Src/user.cpp  **** // }
  83:Src/user.cpp  **** 
  84:Src/user.cpp  **** 
  85:Src/user.cpp  **** // Command handler
  86:Src/user.cpp  **** void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef* hi2c)
  87:Src/user.cpp  **** {
  88:Src/user.cpp  ****     HAL_StatusTypeDef state = HAL_ERROR;
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 3


  89:Src/user.cpp  **** 
  90:Src/user.cpp  ****     float valF = *((float*) (i2cDataRx + 1));
  91:Src/user.cpp  **** 
  92:Src/user.cpp  ****     i2cDataTx[0] = i2cDataRx[0];
  93:Src/user.cpp  ****     switch (i2cDataRx[0])
  94:Src/user.cpp  ****     {
  95:Src/user.cpp  ****         case 0x01:  // Set angle
  96:Src/user.cpp  ****         {
  97:Src/user.cpp  ****             motor.dce.setPointPos = valF;
  98:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 101:Src/user.cpp  ****             break;
 102:Src/user.cpp  ****         }
 103:Src/user.cpp  ****         case 0x02: // Set velocity
 104:Src/user.cpp  ****         {
 105:Src/user.cpp  ****             motor.dce.setPointVel = valF;
 106:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.velocity);
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 109:Src/user.cpp  ****             break;
 110:Src/user.cpp  ****         }
 111:Src/user.cpp  ****         case 0x03: // Set torque
 112:Src/user.cpp  ****         {
 113:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 114:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 117:Src/user.cpp  ****             break;
 118:Src/user.cpp  ****         }
 119:Src/user.cpp  ****         case 0x11: // Get angle
 120:Src/user.cpp  ****         {
 121:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 122:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 124:Src/user.cpp  ****             break;
 125:Src/user.cpp  ****         }
 126:Src/user.cpp  ****         case 0x12: // Get velocity
 127:Src/user.cpp  ****         {
 128:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.velocity);
 129:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 131:Src/user.cpp  ****             break;
 132:Src/user.cpp  ****         }
 133:Src/user.cpp  ****         case 0x21: // Set id
 134:Src/user.cpp  ****         {
 135:Src/user.cpp  ****             boardConfig.nodeId = i2cDataRx[1];
 136:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 137:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 140:Src/user.cpp  ****             break;
 141:Src/user.cpp  ****         }
 142:Src/user.cpp  ****         case 0x22: // Set kp
 143:Src/user.cpp  ****         {
 144:Src/user.cpp  ****             motor.dce.kp = valF;
 145:Src/user.cpp  ****             boardConfig.dceKp = valF;
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 4


 146:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 147:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 150:Src/user.cpp  ****             break;
 151:Src/user.cpp  ****         }
 152:Src/user.cpp  ****         case 0x23: // Set ki
 153:Src/user.cpp  ****         {
 154:Src/user.cpp  ****             motor.dce.ki = valF;
 155:Src/user.cpp  ****             boardConfig.dceKi = valF;
 156:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 157:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 160:Src/user.cpp  ****             break;
 161:Src/user.cpp  ****         }
 162:Src/user.cpp  ****         case 0x24: // Set kv
 163:Src/user.cpp  ****         {
 164:Src/user.cpp  ****             motor.dce.kv = valF;
 165:Src/user.cpp  ****             boardConfig.dceKv = valF;
 166:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 167:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 170:Src/user.cpp  ****             break;
 171:Src/user.cpp  ****         }
 172:Src/user.cpp  ****         case 0x25: // Set kd
 173:Src/user.cpp  ****         {
 174:Src/user.cpp  ****             motor.dce.kd = valF;
 175:Src/user.cpp  ****             boardConfig.dceKd = valF;
 176:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 177:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 180:Src/user.cpp  ****             break;
 181:Src/user.cpp  ****         }
 182:Src/user.cpp  ****         case 0x26: // Set torque limit
 183:Src/user.cpp  ****         {
 184:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 185:Src/user.cpp  ****             boardConfig.toqueLimit = valF;
 186:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 187:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 190:Src/user.cpp  ****             break;
 191:Src/user.cpp  ****         }
 192:Src/user.cpp  ****         case 0x27: // Set init pos
 193:Src/user.cpp  ****         {
 194:Src/user.cpp  ****             boardConfig.initPos = valF;
 195:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 196:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 199:Src/user.cpp  ****             break;
 200:Src/user.cpp  ****         }
 201:Src/user.cpp  ****         case 0xff:
 202:Src/user.cpp  ****             motor.SetEnable(i2cDataRx[1] != 0);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 5


 203:Src/user.cpp  ****             break;
 204:Src/user.cpp  ****         default:
 205:Src/user.cpp  ****             break;
 206:Src/user.cpp  ****     }
 207:Src/user.cpp  **** 
 208:Src/user.cpp  ****     do
 209:Src/user.cpp  ****     {
 210:Src/user.cpp  ****         state = HAL_I2C_Slave_Transmit(&hi2c1, (uint8_t*) i2cDataTx, 5, 10000);
 211:Src/user.cpp  ****     } while (state != HAL_OK);
 212:Src/user.cpp  **** 
 213:Src/user.cpp  ****     do
 214:Src/user.cpp  ****     {
 215:Src/user.cpp  ****         state = HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 216:Src/user.cpp  ****     } while (state != HAL_OK);
 217:Src/user.cpp  **** }
 218:Src/user.cpp  **** 
 219:Src/user.cpp  **** 
 220:Src/user.cpp  **** // Control loop
 221:Src/user.cpp  **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim)
 222:Src/user.cpp  **** {
 223:Src/user.cpp  ****     if (htim->Instance == TIM14)
 224:Src/user.cpp  ****     {
 225:Src/user.cpp  ****         // Read sensor data
 226:Src/user.cpp  ****         HAL_ADC_Start_DMA(&hadc, (uint32_t*) adcData, 1);
 227:Src/user.cpp  **** 
 228:Src/user.cpp  ****         motor.angle = motor.mechanicalAngleMin +
 229:Src/user.cpp  ****                       (motor.mechanicalAngleMax - motor.mechanicalAngleMin) *
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 231:Src/user.cpp  ****                       ((float) motor.adcValAtAngleMax - (float) motor.adcValAtAngleMin);
 232:Src/user.cpp  **** 
 233:Src/user.cpp  ****         // Calculate PID
 234:Src/user.cpp  ****         motor.CalcDceOutput(motor.angle, 0);
 235:Src/user.cpp  ****         motor.SetPwm((int16_t) motor.dce.output);
 236:Src/user.cpp  ****     }
 237:Src/user.cpp  **** }...
  28              		.loc 1 237 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              		.loc 1 237 1 is_stmt 0 view .LVU1
  34 0000 0128     		cmp	r0, #1
  35 0002 00D0     		beq	.L3
  36              	.L1:
  37              		@ sp needed
  38 0004 7047     		bx	lr
  39              	.L3:
  40              		.loc 1 237 1 discriminator 1 view .LVU2
  41 0006 034B     		ldr	r3, .L4
  42 0008 9942     		cmp	r1, r3
  43 000a FBD1     		bne	.L1
  44              	.LVL1:
  45              	.LBB18:
  46              	.LBI18:
  47              		.file 2 "Inc/motor.h"
   1:Inc/motor.h   **** #ifndef SERVODRIVE_FW_MOTOR_H
   2:Inc/motor.h   **** #define SERVODRIVE_FW_MOTOR_H
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 6


   3:Inc/motor.h   **** 
   4:Inc/motor.h   **** #include <cstdint>
   5:Inc/motor.h   **** 
   6:Inc/motor.h   **** class Motor
   7:Inc/motor.h   **** {
   8:Inc/motor.h   **** public:
   9:Inc/motor.h   ****     Motor()
  48              		.loc 2 9 5 is_stmt 1 view .LVU3
  49              	.LBB19:
  50              	.LBB20:
  10:Inc/motor.h   ****     {}
  51              		.loc 2 10 5 is_stmt 0 view .LVU4
  52 000c 024B     		ldr	r3, .L4+4
  53 000e 034A     		ldr	r2, .L4+8
  54 0010 1A60     		str	r2, [r3]
  55              	.LVL2:
  56              		.loc 2 10 5 view .LVU5
  57              	.LBE20:
  58              	.LBE19:
  59              	.LBE18:
  60              		.loc 1 237 1 view .LVU6
  61 0012 F7E7     		b	.L1
  62              	.L5:
  63              		.align	2
  64              	.L4:
  65 0014 FFFF0000 		.word	65535
  66 0018 00000000 		.word	.LANCHOR0
  67 001c 0000FA43 		.word	1140457472
  68              		.cfi_endproc
  69              	.LFE67:
  70              		.cantunwind
  71              		.fnend
  73              		.section	.text.HAL_I2C_SlaveRxCpltCallback,"ax",%progbits
  74              		.align	1
  75              		.global	HAL_I2C_SlaveRxCpltCallback
  76              		.syntax unified
  77              		.code	16
  78              		.thumb_func
  80              	HAL_I2C_SlaveRxCpltCallback:
  81              		.fnstart
  82              	.LVL3:
  83              	.LFB63:
  87:Src/user.cpp  **** {
  84              		.loc 1 87 1 is_stmt 1 view -0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  87:Src/user.cpp  **** {
  88              		.loc 1 87 1 is_stmt 0 view .LVU8
  89 0000 10B5     		push	{r4, lr}
  90              		.save {r4, lr}
  91              	.LCFI0:
  92              		.cfi_def_cfa_offset 8
  93              		.cfi_offset 4, -8
  94              		.cfi_offset 14, -4
  88:Src/user.cpp  ****     HAL_StatusTypeDef state = HAL_ERROR;
  95              		.loc 1 88 5 is_stmt 1 view .LVU9
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 7


  96              	.LVL4:
  90:Src/user.cpp  ****     float valF = *((float*) (i2cDataRx + 1));
  97              		.loc 1 90 5 view .LVU10
  90:Src/user.cpp  ****     float valF = *((float*) (i2cDataRx + 1));
  98              		.loc 1 90 11 is_stmt 0 view .LVU11
  99 0002 764B     		ldr	r3, .L37
 100 0004 5878     		ldrb	r0, [r3, #1]
 101              	.LVL5:
  90:Src/user.cpp  ****     float valF = *((float*) (i2cDataRx + 1));
 102              		.loc 1 90 11 view .LVU12
 103 0006 9978     		ldrb	r1, [r3, #2]
 104 0008 0902     		lsls	r1, r1, #8
 105 000a 0843     		orrs	r0, r1
 106 000c DA78     		ldrb	r2, [r3, #3]
 107 000e 1204     		lsls	r2, r2, #16
 108 0010 0243     		orrs	r2, r0
 109 0012 1C79     		ldrb	r4, [r3, #4]
 110 0014 2406     		lsls	r4, r4, #24
 111 0016 1443     		orrs	r4, r2
 112              	.LVL6:
  92:Src/user.cpp  ****     i2cDataTx[0] = i2cDataRx[0];
 113              		.loc 1 92 5 is_stmt 1 view .LVU13
  92:Src/user.cpp  ****     i2cDataTx[0] = i2cDataRx[0];
 114              		.loc 1 92 31 is_stmt 0 view .LVU14
 115 0018 1B78     		ldrb	r3, [r3]
  92:Src/user.cpp  ****     i2cDataTx[0] = i2cDataRx[0];
 116              		.loc 1 92 18 view .LVU15
 117 001a 714A     		ldr	r2, .L37+4
 118 001c 1370     		strb	r3, [r2]
  93:Src/user.cpp  ****     switch (i2cDataRx[0])
 119              		.loc 1 93 5 is_stmt 1 view .LVU16
 120              	.LBB21:
 121 001e 272B     		cmp	r3, #39
 122 0020 07D8     		bhi	.L7
 123 0022 002B     		cmp	r3, #0
 124 0024 0FD0     		beq	.L33
 125 0026 272B     		cmp	r3, #39
 126 0028 0DD8     		bhi	.L33
 127 002a 9B00     		lsls	r3, r3, #2
 128 002c 6D4A     		ldr	r2, .L37+8
 129 002e D358     		ldr	r3, [r2, r3]
 130 0030 9F46     		mov	pc, r3
 131              		.section	.rodata.HAL_I2C_SlaveRxCpltCallback,"a",%progbits
 132              		.align	2
 133              	.L10:
 134 0000 46000000 		.word	.L33
 135 0004 66000000 		.word	.L21
 136 0008 80000000 		.word	.L20
 137 000c 9A000000 		.word	.L19
 138 0010 46000000 		.word	.L33
 139 0014 46000000 		.word	.L33
 140 0018 46000000 		.word	.L33
 141 001c 46000000 		.word	.L33
 142 0020 46000000 		.word	.L33
 143 0024 46000000 		.word	.L33
 144 0028 46000000 		.word	.L33
 145 002c 46000000 		.word	.L33
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 8


 146 0030 46000000 		.word	.L33
 147 0034 46000000 		.word	.L33
 148 0038 46000000 		.word	.L33
 149 003c 46000000 		.word	.L33
 150 0040 46000000 		.word	.L33
 151 0044 B8000000 		.word	.L35
 152 0048 CE000000 		.word	.L36
 153 004c 46000000 		.word	.L33
 154 0050 46000000 		.word	.L33
 155 0054 46000000 		.word	.L33
 156 0058 46000000 		.word	.L33
 157 005c 46000000 		.word	.L33
 158 0060 46000000 		.word	.L33
 159 0064 46000000 		.word	.L33
 160 0068 46000000 		.word	.L33
 161 006c 46000000 		.word	.L33
 162 0070 46000000 		.word	.L33
 163 0074 46000000 		.word	.L33
 164 0078 46000000 		.word	.L33
 165 007c 46000000 		.word	.L33
 166 0080 46000000 		.word	.L33
 167 0084 E4000000 		.word	.L16
 168 0088 06010000 		.word	.L15
 169 008c 28010000 		.word	.L14
 170 0090 4C010000 		.word	.L13
 171 0094 70010000 		.word	.L12
 172 0098 94010000 		.word	.L11
 173 009c BC010000 		.word	.L9
 174              		.section	.text.HAL_I2C_SlaveRxCpltCallback
 175              	.L7:
 176 0032 FF2B     		cmp	r3, #255
 177 0034 07D1     		bne	.L33
 178              	.LBB22:
 201:Src/user.cpp  ****         case 0xff:
 179              		.loc 1 201 9 view .LVU17
 202:Src/user.cpp  ****             motor.SetEnable(i2cDataRx[1] != 0);
 180              		.loc 1 202 13 view .LVU18
 202:Src/user.cpp  ****             motor.SetEnable(i2cDataRx[1] != 0);
 181              		.loc 1 202 40 is_stmt 0 view .LVU19
 182 0036 694B     		ldr	r3, .L37
 183 0038 5978     		ldrb	r1, [r3, #1]
 202:Src/user.cpp  ****             motor.SetEnable(i2cDataRx[1] != 0);
 184              		.loc 1 202 28 view .LVU20
 185 003a 4B1E     		subs	r3, r1, #1
 186 003c 9941     		sbcs	r1, r1, r3
 187 003e C9B2     		uxtb	r1, r1
 188 0040 6948     		ldr	r0, .L37+12
 189 0042 FFF7FEFF 		bl	_ZN5Motor9SetEnableEb
 190              	.LVL7:
 203:Src/user.cpp  ****             break;
 191              		.loc 1 203 13 is_stmt 1 view .LVU21
 192              	.L33:
 203:Src/user.cpp  ****             break;
 193              		.loc 1 203 13 is_stmt 0 view .LVU22
 194              	.LBE22:
 195              	.LBE21:
 208:Src/user.cpp  ****     do
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 9


 196              		.loc 1 208 5 is_stmt 1 view .LVU23
 210:Src/user.cpp  ****         state = HAL_I2C_Slave_Transmit(&hi2c1, (uint8_t*) i2cDataTx, 5, 10000);
 197              		.loc 1 210 9 view .LVU24
 210:Src/user.cpp  ****         state = HAL_I2C_Slave_Transmit(&hi2c1, (uint8_t*) i2cDataTx, 5, 10000);
 198              		.loc 1 210 39 is_stmt 0 view .LVU25
 199 0046 694B     		ldr	r3, .L37+16
 200 0048 0522     		movs	r2, #5
 201 004a 6549     		ldr	r1, .L37+4
 202 004c 6848     		ldr	r0, .L37+20
 203 004e FFF7FEFF 		bl	HAL_I2C_Slave_Transmit
 204              	.LVL8:
 211:Src/user.cpp  ****     } while (state != HAL_OK);
 205              		.loc 1 211 20 is_stmt 1 view .LVU26
 206 0052 0028     		cmp	r0, #0
 207 0054 F7D1     		bne	.L33
 208              	.L34:
 213:Src/user.cpp  ****     do
 209              		.loc 1 213 5 view .LVU27
 215:Src/user.cpp  ****         state = HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 210              		.loc 1 215 9 view .LVU28
 215:Src/user.cpp  ****         state = HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 211              		.loc 1 215 41 is_stmt 0 view .LVU29
 212 0056 0522     		movs	r2, #5
 213 0058 6049     		ldr	r1, .L37
 214 005a 6548     		ldr	r0, .L37+20
 215              	.LVL9:
 215:Src/user.cpp  ****         state = HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 216              		.loc 1 215 41 view .LVU30
 217 005c FFF7FEFF 		bl	HAL_I2C_Slave_Receive_IT
 218              	.LVL10:
 216:Src/user.cpp  ****     } while (state != HAL_OK);
 219              		.loc 1 216 20 is_stmt 1 view .LVU31
 220 0060 0028     		cmp	r0, #0
 221 0062 F8D1     		bne	.L34
 217:Src/user.cpp  **** }
 222              		.loc 1 217 1 is_stmt 0 view .LVU32
 223              		@ sp needed
 224              	.LVL11:
 217:Src/user.cpp  **** }
 225              		.loc 1 217 1 view .LVU33
 226 0064 10BD     		pop	{r4, pc}
 227              	.LVL12:
 228              	.L21:
 229              	.LBB50:
 230              	.LBB47:
  95:Src/user.cpp  ****         case 0x01:  // Set angle
 231              		.loc 1 95 9 is_stmt 1 view .LVU34
  96:Src/user.cpp  ****         {
 232              		.loc 1 96 9 view .LVU35
 233              	.LBB23:
  97:Src/user.cpp  ****             motor.dce.setPointPos = valF;
 234              		.loc 1 97 13 view .LVU36
  97:Src/user.cpp  ****             motor.dce.setPointPos = valF;
 235              		.loc 1 97 35 is_stmt 0 view .LVU37
 236 0066 604B     		ldr	r3, .L37+12
 237 0068 5C61     		str	r4, [r3, #20]
  98:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 10


 238              		.loc 1 98 13 is_stmt 1 view .LVU38
 239              	.LVL13:
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 240              		.loc 1 99 13 view .LVU39
 241              	.LBB24:
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 242              		.loc 1 99 22 is_stmt 0 view .LVU40
 243 006a 0022     		movs	r2, #0
 244              	.LVL14:
 245              	.L23:
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 246              		.loc 1 99 31 is_stmt 1 discriminator 3 view .LVU41
 247 006c 032A     		cmp	r2, #3
 248 006e EADC     		bgt	.L33
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 249              		.loc 1 100 17 discriminator 2 view .LVU42
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 250              		.loc 1 100 40 is_stmt 0 discriminator 2 view .LVU43
 251 0070 5D4B     		ldr	r3, .L37+12
 252 0072 3033     		adds	r3, r3, #48
 253 0074 9B18     		adds	r3, r3, r2
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 254              		.loc 1 100 29 discriminator 2 view .LVU44
 255 0076 0132     		adds	r2, r2, #1
 256              	.LVL15:
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 257              		.loc 1 100 36 discriminator 2 view .LVU45
 258 0078 1978     		ldrb	r1, [r3]
 100:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 259              		.loc 1 100 34 discriminator 2 view .LVU46
 260 007a 594B     		ldr	r3, .L37+4
 261 007c 9954     		strb	r1, [r3, r2]
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 262              		.loc 1 99 13 is_stmt 1 discriminator 2 view .LVU47
 263              	.LVL16:
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 264              		.loc 1 99 13 is_stmt 0 discriminator 2 view .LVU48
 265 007e F5E7     		b	.L23
 266              	.LVL17:
 267              	.L20:
  99:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 268              		.loc 1 99 13 discriminator 2 view .LVU49
 269              	.LBE24:
 270              	.LBE23:
 103:Src/user.cpp  ****         case 0x02: // Set velocity
 271              		.loc 1 103 9 is_stmt 1 view .LVU50
 104:Src/user.cpp  ****         {
 272              		.loc 1 104 9 view .LVU51
 273              	.LBB25:
 105:Src/user.cpp  ****             motor.dce.setPointVel = valF;
 274              		.loc 1 105 13 view .LVU52
 105:Src/user.cpp  ****             motor.dce.setPointVel = valF;
 275              		.loc 1 105 35 is_stmt 0 view .LVU53
 276 0080 594B     		ldr	r3, .L37+12
 277 0082 9C61     		str	r4, [r3, #24]
 106:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.velocity);
 278              		.loc 1 106 13 is_stmt 1 view .LVU54
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 11


 279              	.LVL18:
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 280              		.loc 1 107 13 view .LVU55
 281              	.LBB26:
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 282              		.loc 1 107 22 is_stmt 0 view .LVU56
 283 0084 0022     		movs	r2, #0
 284              	.LVL19:
 285              	.L24:
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 286              		.loc 1 107 31 is_stmt 1 discriminator 3 view .LVU57
 287 0086 032A     		cmp	r2, #3
 288 0088 DDDC     		bgt	.L33
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 289              		.loc 1 108 17 discriminator 2 view .LVU58
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 290              		.loc 1 108 40 is_stmt 0 discriminator 2 view .LVU59
 291 008a 574B     		ldr	r3, .L37+12
 292 008c 3433     		adds	r3, r3, #52
 293 008e 9B18     		adds	r3, r3, r2
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 294              		.loc 1 108 29 discriminator 2 view .LVU60
 295 0090 0132     		adds	r2, r2, #1
 296              	.LVL20:
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 297              		.loc 1 108 36 discriminator 2 view .LVU61
 298 0092 1978     		ldrb	r1, [r3]
 108:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 299              		.loc 1 108 34 discriminator 2 view .LVU62
 300 0094 524B     		ldr	r3, .L37+4
 301 0096 9954     		strb	r1, [r3, r2]
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 302              		.loc 1 107 13 is_stmt 1 discriminator 2 view .LVU63
 303              	.LVL21:
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 304              		.loc 1 107 13 is_stmt 0 discriminator 2 view .LVU64
 305 0098 F5E7     		b	.L24
 306              	.LVL22:
 307              	.L19:
 107:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 308              		.loc 1 107 13 discriminator 2 view .LVU65
 309              	.LBE26:
 310              	.LBE25:
 111:Src/user.cpp  ****         case 0x03: // Set torque
 311              		.loc 1 111 9 is_stmt 1 view .LVU66
 112:Src/user.cpp  ****         {
 312              		.loc 1 112 9 view .LVU67
 313              	.LBB27:
 113:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 314              		.loc 1 113 13 view .LVU68
 113:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 315              		.loc 1 113 33 is_stmt 0 view .LVU69
 316 009a 211C     		adds	r1, r4, #0
 317 009c 5248     		ldr	r0, .L37+12
 318 009e FFF7FEFF 		bl	_ZN5Motor14SetTorqueLimitEf
 319              	.LVL23:
 114:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 12


 320              		.loc 1 114 13 is_stmt 1 view .LVU70
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 321              		.loc 1 115 13 view .LVU71
 322              	.LBB28:
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 323              		.loc 1 115 22 is_stmt 0 view .LVU72
 324 00a2 0022     		movs	r2, #0
 325              	.LVL24:
 326              	.L25:
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 327              		.loc 1 115 31 is_stmt 1 discriminator 3 view .LVU73
 328 00a4 032A     		cmp	r2, #3
 329 00a6 CEDC     		bgt	.L33
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 330              		.loc 1 116 17 discriminator 2 view .LVU74
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 331              		.loc 1 116 40 is_stmt 0 discriminator 2 view .LVU75
 332 00a8 4F4B     		ldr	r3, .L37+12
 333 00aa 3033     		adds	r3, r3, #48
 334 00ac 9B18     		adds	r3, r3, r2
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 335              		.loc 1 116 29 discriminator 2 view .LVU76
 336 00ae 0132     		adds	r2, r2, #1
 337              	.LVL25:
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 338              		.loc 1 116 36 discriminator 2 view .LVU77
 339 00b0 1978     		ldrb	r1, [r3]
 116:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 340              		.loc 1 116 34 discriminator 2 view .LVU78
 341 00b2 4B4B     		ldr	r3, .L37+4
 342 00b4 9954     		strb	r1, [r3, r2]
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 343              		.loc 1 115 13 is_stmt 1 discriminator 2 view .LVU79
 344              	.LVL26:
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 345              		.loc 1 115 13 is_stmt 0 discriminator 2 view .LVU80
 346 00b6 F5E7     		b	.L25
 347              	.LVL27:
 348              	.L35:
 115:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 349              		.loc 1 115 13 discriminator 2 view .LVU81
 350              	.LBE28:
 351              	.LBE27:
 352              	.LBE47:
  93:Src/user.cpp  ****     switch (i2cDataRx[0])
 353              		.loc 1 93 5 view .LVU82
 354 00b8 0022     		movs	r2, #0
 355              	.L18:
 356              	.LVL28:
 357              	.LBB48:
 358              	.LBB29:
 359              	.LBB30:
 122:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 360              		.loc 1 122 31 is_stmt 1 discriminator 3 view .LVU83
 361 00ba 032A     		cmp	r2, #3
 362 00bc C3DC     		bgt	.L33
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 13


 363              		.loc 1 123 17 discriminator 2 view .LVU84
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 364              		.loc 1 123 40 is_stmt 0 discriminator 2 view .LVU85
 365 00be 4A4B     		ldr	r3, .L37+12
 366 00c0 3033     		adds	r3, r3, #48
 367 00c2 9B18     		adds	r3, r3, r2
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 368              		.loc 1 123 29 discriminator 2 view .LVU86
 369 00c4 0132     		adds	r2, r2, #1
 370              	.LVL29:
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 371              		.loc 1 123 36 discriminator 2 view .LVU87
 372 00c6 1978     		ldrb	r1, [r3]
 123:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 373              		.loc 1 123 34 discriminator 2 view .LVU88
 374 00c8 454B     		ldr	r3, .L37+4
 375 00ca 9954     		strb	r1, [r3, r2]
 122:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 376              		.loc 1 122 13 is_stmt 1 discriminator 2 view .LVU89
 377              	.LVL30:
 122:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 378              		.loc 1 122 13 is_stmt 0 discriminator 2 view .LVU90
 379 00cc F5E7     		b	.L18
 380              	.LVL31:
 381              	.L36:
 122:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 382              		.loc 1 122 13 discriminator 2 view .LVU91
 383              	.LBE30:
 384              	.LBE29:
 385              	.LBE48:
  93:Src/user.cpp  ****     switch (i2cDataRx[0])
 386              		.loc 1 93 5 view .LVU92
 387 00ce 0022     		movs	r2, #0
 388              	.L17:
 389              	.LVL32:
 390              	.LBB49:
 391              	.LBB31:
 392              	.LBB32:
 129:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 393              		.loc 1 129 31 is_stmt 1 discriminator 3 view .LVU93
 394 00d0 032A     		cmp	r2, #3
 395 00d2 B8DC     		bgt	.L33
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 396              		.loc 1 130 17 discriminator 2 view .LVU94
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 397              		.loc 1 130 40 is_stmt 0 discriminator 2 view .LVU95
 398 00d4 444B     		ldr	r3, .L37+12
 399 00d6 3433     		adds	r3, r3, #52
 400 00d8 9B18     		adds	r3, r3, r2
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 401              		.loc 1 130 29 discriminator 2 view .LVU96
 402 00da 0132     		adds	r2, r2, #1
 403              	.LVL33:
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 404              		.loc 1 130 36 discriminator 2 view .LVU97
 405 00dc 1978     		ldrb	r1, [r3]
 130:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 14


 406              		.loc 1 130 34 discriminator 2 view .LVU98
 407 00de 404B     		ldr	r3, .L37+4
 408 00e0 9954     		strb	r1, [r3, r2]
 129:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 409              		.loc 1 129 13 is_stmt 1 discriminator 2 view .LVU99
 410              	.LVL34:
 129:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 411              		.loc 1 129 13 is_stmt 0 discriminator 2 view .LVU100
 412 00e2 F5E7     		b	.L17
 413              	.LVL35:
 414              	.L16:
 129:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 415              		.loc 1 129 13 discriminator 2 view .LVU101
 416              	.LBE32:
 417              	.LBE31:
 133:Src/user.cpp  ****         case 0x21: // Set id
 418              		.loc 1 133 9 is_stmt 1 view .LVU102
 134:Src/user.cpp  ****         {
 419              		.loc 1 134 9 view .LVU103
 420              	.LBB33:
 135:Src/user.cpp  ****             boardConfig.nodeId = i2cDataRx[1];
 421              		.loc 1 135 13 view .LVU104
 135:Src/user.cpp  ****             boardConfig.nodeId = i2cDataRx[1];
 422              		.loc 1 135 45 is_stmt 0 view .LVU105
 423 00e4 3D4B     		ldr	r3, .L37
 424 00e6 5A78     		ldrb	r2, [r3, #1]
 135:Src/user.cpp  ****             boardConfig.nodeId = i2cDataRx[1];
 425              		.loc 1 135 32 view .LVU106
 426 00e8 424B     		ldr	r3, .L37+24
 427 00ea 5A70     		strb	r2, [r3, #1]
 136:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 428              		.loc 1 136 13 is_stmt 1 view .LVU107
 136:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 429              		.loc 1 136 38 is_stmt 0 view .LVU108
 430 00ec 0222     		movs	r2, #2
 431 00ee 1A70     		strb	r2, [r3]
 137:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 432              		.loc 1 137 13 is_stmt 1 view .LVU109
 433              	.LVL36:
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 434              		.loc 1 138 13 view .LVU110
 435              	.LBB34:
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 436              		.loc 1 138 22 is_stmt 0 view .LVU111
 437 00f0 0022     		movs	r2, #0
 438              	.LVL37:
 439              	.L26:
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 440              		.loc 1 138 31 is_stmt 1 discriminator 3 view .LVU112
 441 00f2 032A     		cmp	r2, #3
 442 00f4 A7DC     		bgt	.L33
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 443              		.loc 1 139 17 discriminator 2 view .LVU113
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 444              		.loc 1 139 40 is_stmt 0 discriminator 2 view .LVU114
 445 00f6 3C4B     		ldr	r3, .L37+12
 446 00f8 3033     		adds	r3, r3, #48
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 15


 447 00fa 9B18     		adds	r3, r3, r2
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 448              		.loc 1 139 29 discriminator 2 view .LVU115
 449 00fc 0132     		adds	r2, r2, #1
 450              	.LVL38:
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 451              		.loc 1 139 36 discriminator 2 view .LVU116
 452 00fe 1978     		ldrb	r1, [r3]
 139:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 453              		.loc 1 139 34 discriminator 2 view .LVU117
 454 0100 374B     		ldr	r3, .L37+4
 455 0102 9954     		strb	r1, [r3, r2]
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 456              		.loc 1 138 13 is_stmt 1 discriminator 2 view .LVU118
 457              	.LVL39:
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 458              		.loc 1 138 13 is_stmt 0 discriminator 2 view .LVU119
 459 0104 F5E7     		b	.L26
 460              	.LVL40:
 461              	.L15:
 138:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 462              		.loc 1 138 13 discriminator 2 view .LVU120
 463              	.LBE34:
 464              	.LBE33:
 142:Src/user.cpp  ****         case 0x22: // Set kp
 465              		.loc 1 142 9 is_stmt 1 view .LVU121
 143:Src/user.cpp  ****         {
 466              		.loc 1 143 9 view .LVU122
 467              	.LBB35:
 144:Src/user.cpp  ****             motor.dce.kp = valF;
 468              		.loc 1 144 13 view .LVU123
 144:Src/user.cpp  ****             motor.dce.kp = valF;
 469              		.loc 1 144 26 is_stmt 0 view .LVU124
 470 0106 384B     		ldr	r3, .L37+12
 471 0108 5C60     		str	r4, [r3, #4]
 145:Src/user.cpp  ****             boardConfig.dceKp = valF;
 472              		.loc 1 145 13 is_stmt 1 view .LVU125
 145:Src/user.cpp  ****             boardConfig.dceKp = valF;
 473              		.loc 1 145 31 is_stmt 0 view .LVU126
 474 010a 3A4B     		ldr	r3, .L37+24
 475 010c DC61     		str	r4, [r3, #28]
 146:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 476              		.loc 1 146 13 is_stmt 1 view .LVU127
 146:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 477              		.loc 1 146 38 is_stmt 0 view .LVU128
 478 010e 0222     		movs	r2, #2
 479 0110 1A70     		strb	r2, [r3]
 147:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 480              		.loc 1 147 13 is_stmt 1 view .LVU129
 481              	.LVL41:
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 482              		.loc 1 148 13 view .LVU130
 483              	.LBB36:
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 484              		.loc 1 148 22 is_stmt 0 view .LVU131
 485 0112 0022     		movs	r2, #0
 486              	.LVL42:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 16


 487              	.L27:
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 488              		.loc 1 148 31 is_stmt 1 discriminator 3 view .LVU132
 489 0114 032A     		cmp	r2, #3
 490 0116 96DC     		bgt	.L33
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 491              		.loc 1 149 17 discriminator 2 view .LVU133
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 492              		.loc 1 149 40 is_stmt 0 discriminator 2 view .LVU134
 493 0118 334B     		ldr	r3, .L37+12
 494 011a 3033     		adds	r3, r3, #48
 495 011c 9B18     		adds	r3, r3, r2
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 496              		.loc 1 149 29 discriminator 2 view .LVU135
 497 011e 0132     		adds	r2, r2, #1
 498              	.LVL43:
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 499              		.loc 1 149 36 discriminator 2 view .LVU136
 500 0120 1978     		ldrb	r1, [r3]
 149:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 501              		.loc 1 149 34 discriminator 2 view .LVU137
 502 0122 2F4B     		ldr	r3, .L37+4
 503 0124 9954     		strb	r1, [r3, r2]
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 504              		.loc 1 148 13 is_stmt 1 discriminator 2 view .LVU138
 505              	.LVL44:
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 506              		.loc 1 148 13 is_stmt 0 discriminator 2 view .LVU139
 507 0126 F5E7     		b	.L27
 508              	.LVL45:
 509              	.L14:
 148:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 510              		.loc 1 148 13 discriminator 2 view .LVU140
 511              	.LBE36:
 512              	.LBE35:
 152:Src/user.cpp  ****         case 0x23: // Set ki
 513              		.loc 1 152 9 is_stmt 1 view .LVU141
 153:Src/user.cpp  ****         {
 514              		.loc 1 153 9 view .LVU142
 515              	.LBB37:
 154:Src/user.cpp  ****             motor.dce.ki = valF;
 516              		.loc 1 154 13 view .LVU143
 154:Src/user.cpp  ****             motor.dce.ki = valF;
 517              		.loc 1 154 26 is_stmt 0 view .LVU144
 518 0128 2F4B     		ldr	r3, .L37+12
 519 012a DC60     		str	r4, [r3, #12]
 155:Src/user.cpp  ****             boardConfig.dceKi = valF;
 520              		.loc 1 155 13 is_stmt 1 view .LVU145
 155:Src/user.cpp  ****             boardConfig.dceKi = valF;
 521              		.loc 1 155 31 is_stmt 0 view .LVU146
 522 012c 314B     		ldr	r3, .L37+24
 523 012e 5C62     		str	r4, [r3, #36]
 156:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 524              		.loc 1 156 13 is_stmt 1 view .LVU147
 156:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 525              		.loc 1 156 38 is_stmt 0 view .LVU148
 526 0130 0222     		movs	r2, #2
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 17


 527 0132 1A70     		strb	r2, [r3]
 157:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 528              		.loc 1 157 13 is_stmt 1 view .LVU149
 529              	.LVL46:
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 530              		.loc 1 158 13 view .LVU150
 531              	.LBB38:
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 532              		.loc 1 158 22 is_stmt 0 view .LVU151
 533 0134 0022     		movs	r2, #0
 534              	.LVL47:
 535              	.L28:
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 536              		.loc 1 158 31 is_stmt 1 discriminator 3 view .LVU152
 537 0136 032A     		cmp	r2, #3
 538 0138 00DD     		ble	.LCB434
 539 013a 84E7     		b	.L33	@long jump
 540              	.LCB434:
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 541              		.loc 1 159 17 discriminator 2 view .LVU153
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 542              		.loc 1 159 40 is_stmt 0 discriminator 2 view .LVU154
 543 013c 2A4B     		ldr	r3, .L37+12
 544 013e 3033     		adds	r3, r3, #48
 545 0140 9B18     		adds	r3, r3, r2
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 546              		.loc 1 159 29 discriminator 2 view .LVU155
 547 0142 0132     		adds	r2, r2, #1
 548              	.LVL48:
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 549              		.loc 1 159 36 discriminator 2 view .LVU156
 550 0144 1978     		ldrb	r1, [r3]
 159:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 551              		.loc 1 159 34 discriminator 2 view .LVU157
 552 0146 264B     		ldr	r3, .L37+4
 553 0148 9954     		strb	r1, [r3, r2]
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 554              		.loc 1 158 13 is_stmt 1 discriminator 2 view .LVU158
 555              	.LVL49:
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 556              		.loc 1 158 13 is_stmt 0 discriminator 2 view .LVU159
 557 014a F4E7     		b	.L28
 558              	.LVL50:
 559              	.L13:
 158:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 560              		.loc 1 158 13 discriminator 2 view .LVU160
 561              	.LBE38:
 562              	.LBE37:
 162:Src/user.cpp  ****         case 0x24: // Set kv
 563              		.loc 1 162 9 is_stmt 1 view .LVU161
 163:Src/user.cpp  ****         {
 564              		.loc 1 163 9 view .LVU162
 565              	.LBB39:
 164:Src/user.cpp  ****             motor.dce.kv = valF;
 566              		.loc 1 164 13 view .LVU163
 164:Src/user.cpp  ****             motor.dce.kv = valF;
 567              		.loc 1 164 26 is_stmt 0 view .LVU164
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 18


 568 014c 264B     		ldr	r3, .L37+12
 569 014e 9C60     		str	r4, [r3, #8]
 165:Src/user.cpp  ****             boardConfig.dceKv = valF;
 570              		.loc 1 165 13 is_stmt 1 view .LVU165
 165:Src/user.cpp  ****             boardConfig.dceKv = valF;
 571              		.loc 1 165 31 is_stmt 0 view .LVU166
 572 0150 284B     		ldr	r3, .L37+24
 573 0152 1C62     		str	r4, [r3, #32]
 166:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 574              		.loc 1 166 13 is_stmt 1 view .LVU167
 166:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 575              		.loc 1 166 38 is_stmt 0 view .LVU168
 576 0154 0222     		movs	r2, #2
 577 0156 1A70     		strb	r2, [r3]
 167:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 578              		.loc 1 167 13 is_stmt 1 view .LVU169
 579              	.LVL51:
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 580              		.loc 1 168 13 view .LVU170
 581              	.LBB40:
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 582              		.loc 1 168 22 is_stmt 0 view .LVU171
 583 0158 0022     		movs	r2, #0
 584              	.LVL52:
 585              	.L29:
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 586              		.loc 1 168 31 is_stmt 1 discriminator 3 view .LVU172
 587 015a 032A     		cmp	r2, #3
 588 015c 00DD     		ble	.LCB478
 589 015e 72E7     		b	.L33	@long jump
 590              	.LCB478:
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 591              		.loc 1 169 17 discriminator 2 view .LVU173
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 592              		.loc 1 169 40 is_stmt 0 discriminator 2 view .LVU174
 593 0160 214B     		ldr	r3, .L37+12
 594 0162 3033     		adds	r3, r3, #48
 595 0164 9B18     		adds	r3, r3, r2
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 596              		.loc 1 169 29 discriminator 2 view .LVU175
 597 0166 0132     		adds	r2, r2, #1
 598              	.LVL53:
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 599              		.loc 1 169 36 discriminator 2 view .LVU176
 600 0168 1978     		ldrb	r1, [r3]
 169:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 601              		.loc 1 169 34 discriminator 2 view .LVU177
 602 016a 1D4B     		ldr	r3, .L37+4
 603 016c 9954     		strb	r1, [r3, r2]
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 604              		.loc 1 168 13 is_stmt 1 discriminator 2 view .LVU178
 605              	.LVL54:
 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 606              		.loc 1 168 13 is_stmt 0 discriminator 2 view .LVU179
 607 016e F4E7     		b	.L29
 608              	.LVL55:
 609              	.L12:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 19


 168:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 610              		.loc 1 168 13 discriminator 2 view .LVU180
 611              	.LBE40:
 612              	.LBE39:
 172:Src/user.cpp  ****         case 0x25: // Set kd
 613              		.loc 1 172 9 is_stmt 1 view .LVU181
 173:Src/user.cpp  ****         {
 614              		.loc 1 173 9 view .LVU182
 615              	.LBB41:
 174:Src/user.cpp  ****             motor.dce.kd = valF;
 616              		.loc 1 174 13 view .LVU183
 174:Src/user.cpp  ****             motor.dce.kd = valF;
 617              		.loc 1 174 26 is_stmt 0 view .LVU184
 618 0170 1D4B     		ldr	r3, .L37+12
 619 0172 1C61     		str	r4, [r3, #16]
 175:Src/user.cpp  ****             boardConfig.dceKd = valF;
 620              		.loc 1 175 13 is_stmt 1 view .LVU185
 175:Src/user.cpp  ****             boardConfig.dceKd = valF;
 621              		.loc 1 175 31 is_stmt 0 view .LVU186
 622 0174 1F4B     		ldr	r3, .L37+24
 623 0176 9C62     		str	r4, [r3, #40]
 176:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 624              		.loc 1 176 13 is_stmt 1 view .LVU187
 176:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 625              		.loc 1 176 38 is_stmt 0 view .LVU188
 626 0178 0222     		movs	r2, #2
 627 017a 1A70     		strb	r2, [r3]
 177:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 628              		.loc 1 177 13 is_stmt 1 view .LVU189
 629              	.LVL56:
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 630              		.loc 1 178 13 view .LVU190
 631              	.LBB42:
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 632              		.loc 1 178 22 is_stmt 0 view .LVU191
 633 017c 0022     		movs	r2, #0
 634              	.LVL57:
 635              	.L30:
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 636              		.loc 1 178 31 is_stmt 1 discriminator 3 view .LVU192
 637 017e 032A     		cmp	r2, #3
 638 0180 00DD     		ble	.LCB522
 639 0182 60E7     		b	.L33	@long jump
 640              	.LCB522:
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 641              		.loc 1 179 17 discriminator 2 view .LVU193
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 642              		.loc 1 179 40 is_stmt 0 discriminator 2 view .LVU194
 643 0184 184B     		ldr	r3, .L37+12
 644 0186 3033     		adds	r3, r3, #48
 645 0188 9B18     		adds	r3, r3, r2
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 646              		.loc 1 179 29 discriminator 2 view .LVU195
 647 018a 0132     		adds	r2, r2, #1
 648              	.LVL58:
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 649              		.loc 1 179 36 discriminator 2 view .LVU196
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 20


 650 018c 1978     		ldrb	r1, [r3]
 179:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 651              		.loc 1 179 34 discriminator 2 view .LVU197
 652 018e 144B     		ldr	r3, .L37+4
 653 0190 9954     		strb	r1, [r3, r2]
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 654              		.loc 1 178 13 is_stmt 1 discriminator 2 view .LVU198
 655              	.LVL59:
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 656              		.loc 1 178 13 is_stmt 0 discriminator 2 view .LVU199
 657 0192 F4E7     		b	.L30
 658              	.LVL60:
 659              	.L11:
 178:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 660              		.loc 1 178 13 discriminator 2 view .LVU200
 661              	.LBE42:
 662              	.LBE41:
 182:Src/user.cpp  ****         case 0x26: // Set torque limit
 663              		.loc 1 182 9 is_stmt 1 view .LVU201
 183:Src/user.cpp  ****         {
 664              		.loc 1 183 9 view .LVU202
 665              	.LBB43:
 184:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 666              		.loc 1 184 13 view .LVU203
 184:Src/user.cpp  ****             motor.SetTorqueLimit(valF);
 667              		.loc 1 184 33 is_stmt 0 view .LVU204
 668 0194 211C     		adds	r1, r4, #0
 669 0196 1448     		ldr	r0, .L37+12
 670 0198 FFF7FEFF 		bl	_ZN5Motor14SetTorqueLimitEf
 671              	.LVL61:
 185:Src/user.cpp  ****             boardConfig.toqueLimit = valF;
 672              		.loc 1 185 13 is_stmt 1 view .LVU205
 185:Src/user.cpp  ****             boardConfig.toqueLimit = valF;
 673              		.loc 1 185 36 is_stmt 0 view .LVU206
 674 019c 154B     		ldr	r3, .L37+24
 675 019e 9C60     		str	r4, [r3, #8]
 186:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 676              		.loc 1 186 13 is_stmt 1 view .LVU207
 186:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 677              		.loc 1 186 38 is_stmt 0 view .LVU208
 678 01a0 0222     		movs	r2, #2
 679 01a2 1A70     		strb	r2, [r3]
 187:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 680              		.loc 1 187 13 is_stmt 1 view .LVU209
 681              	.LVL62:
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 682              		.loc 1 188 13 view .LVU210
 683              	.LBB44:
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 684              		.loc 1 188 22 is_stmt 0 view .LVU211
 685 01a4 0022     		movs	r2, #0
 686              	.LVL63:
 687              	.L31:
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 688              		.loc 1 188 31 is_stmt 1 discriminator 3 view .LVU212
 689 01a6 032A     		cmp	r2, #3
 690 01a8 00DD     		ble	.LCB567
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 21


 691 01aa 4CE7     		b	.L33	@long jump
 692              	.LCB567:
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 693              		.loc 1 189 17 discriminator 2 view .LVU213
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 694              		.loc 1 189 40 is_stmt 0 discriminator 2 view .LVU214
 695 01ac 0E4B     		ldr	r3, .L37+12
 696 01ae 3033     		adds	r3, r3, #48
 697 01b0 9B18     		adds	r3, r3, r2
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 698              		.loc 1 189 29 discriminator 2 view .LVU215
 699 01b2 0132     		adds	r2, r2, #1
 700              	.LVL64:
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 701              		.loc 1 189 36 discriminator 2 view .LVU216
 702 01b4 1978     		ldrb	r1, [r3]
 189:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 703              		.loc 1 189 34 discriminator 2 view .LVU217
 704 01b6 0A4B     		ldr	r3, .L37+4
 705 01b8 9954     		strb	r1, [r3, r2]
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 706              		.loc 1 188 13 is_stmt 1 discriminator 2 view .LVU218
 707              	.LVL65:
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 708              		.loc 1 188 13 is_stmt 0 discriminator 2 view .LVU219
 709 01ba F4E7     		b	.L31
 710              	.LVL66:
 711              	.L9:
 188:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 712              		.loc 1 188 13 discriminator 2 view .LVU220
 713              	.LBE44:
 714              	.LBE43:
 192:Src/user.cpp  ****         case 0x27: // Set init pos
 715              		.loc 1 192 9 is_stmt 1 view .LVU221
 193:Src/user.cpp  ****         {
 716              		.loc 1 193 9 view .LVU222
 717              	.LBB45:
 194:Src/user.cpp  ****             boardConfig.initPos = valF;
 718              		.loc 1 194 13 view .LVU223
 194:Src/user.cpp  ****             boardConfig.initPos = valF;
 719              		.loc 1 194 33 is_stmt 0 view .LVU224
 720 01bc 0D4B     		ldr	r3, .L37+24
 721 01be 5C60     		str	r4, [r3, #4]
 195:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 722              		.loc 1 195 13 is_stmt 1 view .LVU225
 195:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_COMMIT;
 723              		.loc 1 195 38 is_stmt 0 view .LVU226
 724 01c0 0222     		movs	r2, #2
 725 01c2 1A70     		strb	r2, [r3]
 196:Src/user.cpp  ****             auto* b = (unsigned char*) &(motor.angle);
 726              		.loc 1 196 13 is_stmt 1 view .LVU227
 727              	.LVL67:
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 728              		.loc 1 197 13 view .LVU228
 729              	.LBB46:
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 730              		.loc 1 197 22 is_stmt 0 view .LVU229
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 22


 731 01c4 0022     		movs	r2, #0
 732              	.LVL68:
 733              	.L32:
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 734              		.loc 1 197 31 is_stmt 1 discriminator 3 view .LVU230
 735 01c6 032A     		cmp	r2, #3
 736 01c8 00DD     		ble	.LCB608
 737 01ca 3CE7     		b	.L33	@long jump
 738              	.LCB608:
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 739              		.loc 1 198 17 discriminator 2 view .LVU231
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 740              		.loc 1 198 40 is_stmt 0 discriminator 2 view .LVU232
 741 01cc 064B     		ldr	r3, .L37+12
 742 01ce 3033     		adds	r3, r3, #48
 743 01d0 9B18     		adds	r3, r3, r2
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 744              		.loc 1 198 29 discriminator 2 view .LVU233
 745 01d2 0132     		adds	r2, r2, #1
 746              	.LVL69:
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 747              		.loc 1 198 36 discriminator 2 view .LVU234
 748 01d4 1978     		ldrb	r1, [r3]
 198:Src/user.cpp  ****                 i2cDataTx[i + 1] = *(b + i);
 749              		.loc 1 198 34 discriminator 2 view .LVU235
 750 01d6 024B     		ldr	r3, .L37+4
 751 01d8 9954     		strb	r1, [r3, r2]
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 752              		.loc 1 197 13 is_stmt 1 discriminator 2 view .LVU236
 753              	.LVL70:
 197:Src/user.cpp  ****             for (int i = 0; i < 4; i++)
 754              		.loc 1 197 13 is_stmt 0 discriminator 2 view .LVU237
 755 01da F4E7     		b	.L32
 756              	.L38:
 757              		.align	2
 758              	.L37:
 759 01dc 00000000 		.word	i2cDataRx
 760 01e0 00000000 		.word	i2cDataTx
 761 01e4 00000000 		.word	.L10
 762 01e8 00000000 		.word	.LANCHOR0
 763 01ec 10270000 		.word	10000
 764 01f0 00000000 		.word	hi2c1
 765 01f4 00000000 		.word	.LANCHOR1
 766              	.LBE46:
 767              	.LBE45:
 768              	.LBE49:
 769              	.LBE50:
 770              		.cfi_endproc
 771              	.LFE63:
 772              		.fnend
 774              		.global	__aeabi_fsub
 775              		.global	__aeabi_ui2f
 776              		.global	__aeabi_fmul
 777              		.global	__aeabi_fdiv
 778              		.global	__aeabi_fadd
 779              		.global	__aeabi_f2iz
 780              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 23


 781              		.align	1
 782              		.global	HAL_TIM_PeriodElapsedCallback
 783              		.syntax unified
 784              		.code	16
 785              		.thumb_func
 787              	HAL_TIM_PeriodElapsedCallback:
 788              		.fnstart
 789              	.LVL71:
 790              	.LFB64:
 222:Src/user.cpp  **** {
 791              		.loc 1 222 1 is_stmt 1 view -0
 792              		.cfi_startproc
 793              		@ args = 0, pretend = 0, frame = 0
 794              		@ frame_needed = 0, uses_anonymous_args = 0
 222:Src/user.cpp  **** {
 795              		.loc 1 222 1 is_stmt 0 view .LVU239
 796 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 797              		.save {r4, r5, r6, r7, lr}
 798              	.LCFI1:
 799              		.cfi_def_cfa_offset 20
 800              		.cfi_offset 4, -20
 801              		.cfi_offset 5, -16
 802              		.cfi_offset 6, -12
 803              		.cfi_offset 7, -8
 804              		.cfi_offset 14, -4
 805 0002 C646     		mov	lr, r8
 806 0004 00B5     		push	{lr}
 807              		.save {r8}
 808              	.LCFI2:
 809              		.cfi_def_cfa_offset 24
 810              		.cfi_offset 8, -24
 223:Src/user.cpp  ****     if (htim->Instance == TIM14)
 811              		.loc 1 223 5 is_stmt 1 view .LVU240
 223:Src/user.cpp  ****     if (htim->Instance == TIM14)
 812              		.loc 1 223 15 is_stmt 0 view .LVU241
 813 0006 0268     		ldr	r2, [r0]
 223:Src/user.cpp  ****     if (htim->Instance == TIM14)
 814              		.loc 1 223 5 view .LVU242
 815 0008 1F4B     		ldr	r3, .L42
 816 000a 9A42     		cmp	r2, r3
 817 000c 02D0     		beq	.L41
 818              	.LVL72:
 819              	.L39:
 820              		.loc 1 237 1 view .LVU243
 821              		@ sp needed
 822 000e 80BC     		pop	{r7}
 823 0010 B846     		mov	r8, r7
 824 0012 F0BD     		pop	{r4, r5, r6, r7, pc}
 825              	.LVL73:
 826              	.L41:
 226:Src/user.cpp  ****         HAL_ADC_Start_DMA(&hadc, (uint32_t*) adcData, 1);
 827              		.loc 1 226 9 is_stmt 1 view .LVU244
 226:Src/user.cpp  ****         HAL_ADC_Start_DMA(&hadc, (uint32_t*) adcData, 1);
 828              		.loc 1 226 26 is_stmt 0 view .LVU245
 829 0014 1D4D     		ldr	r5, .L42+4
 830 0016 0122     		movs	r2, #1
 831 0018 2900     		movs	r1, r5
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 24


 832 001a 1D48     		ldr	r0, .L42+8
 833              	.LVL74:
 226:Src/user.cpp  ****         HAL_ADC_Start_DMA(&hadc, (uint32_t*) adcData, 1);
 834              		.loc 1 226 26 view .LVU246
 835 001c FFF7FEFF 		bl	HAL_ADC_Start_DMA
 836              	.LVL75:
 228:Src/user.cpp  ****         motor.angle = motor.mechanicalAngleMin +
 837              		.loc 1 228 9 is_stmt 1 view .LVU247
 228:Src/user.cpp  ****         motor.angle = motor.mechanicalAngleMin +
 838              		.loc 1 228 29 is_stmt 0 view .LVU248
 839 0020 1C4C     		ldr	r4, .L42+12
 840 0022 A76B     		ldr	r7, [r4, #56]
 229:Src/user.cpp  ****                       (motor.mechanicalAngleMax - motor.mechanicalAngleMin) *
 841              		.loc 1 229 49 view .LVU249
 842 0024 391C     		adds	r1, r7, #0
 843 0026 E06B     		ldr	r0, [r4, #60]
 844 0028 FFF7FEFF 		bl	__aeabi_fsub
 845              	.LVL76:
 846 002c 061C     		adds	r6, r0, #0
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 847              		.loc 1 230 41 view .LVU250
 848 002e 2888     		ldrh	r0, [r5]
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 849              		.loc 1 230 24 view .LVU251
 850 0030 FFF7FEFF 		bl	__aeabi_ui2f
 851              	.LVL77:
 852 0034 8046     		mov	r8, r0
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 853              		.loc 1 230 59 view .LVU252
 854 0036 A08D     		ldrh	r0, [r4, #44]
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 855              		.loc 1 230 45 view .LVU253
 856 0038 FFF7FEFF 		bl	__aeabi_ui2f
 857              	.LVL78:
 858 003c 051C     		adds	r5, r0, #0
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 859              		.loc 1 230 43 view .LVU254
 860 003e 011C     		adds	r1, r0, #0
 861 0040 4046     		mov	r0, r8
 862 0042 FFF7FEFF 		bl	__aeabi_fsub
 863              	.LVL79:
 864 0046 011C     		adds	r1, r0, #0
 229:Src/user.cpp  ****                       (motor.mechanicalAngleMax - motor.mechanicalAngleMin) *
 865              		.loc 1 229 77 view .LVU255
 866 0048 301C     		adds	r0, r6, #0
 867 004a FFF7FEFF 		bl	__aeabi_fmul
 868              	.LVL80:
 869 004e 061C     		adds	r6, r0, #0
 231:Src/user.cpp  ****                       ((float) motor.adcValAtAngleMax - (float) motor.adcValAtAngleMin);
 870              		.loc 1 231 38 view .LVU256
 871 0050 E08D     		ldrh	r0, [r4, #46]
 231:Src/user.cpp  ****                       ((float) motor.adcValAtAngleMax - (float) motor.adcValAtAngleMin);
 872              		.loc 1 231 24 view .LVU257
 873 0052 FFF7FEFF 		bl	__aeabi_ui2f
 874              	.LVL81:
 231:Src/user.cpp  ****                       ((float) motor.adcValAtAngleMax - (float) motor.adcValAtAngleMin);
 875              		.loc 1 231 55 view .LVU258
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 25


 876 0056 291C     		adds	r1, r5, #0
 877 0058 FFF7FEFF 		bl	__aeabi_fsub
 878              	.LVL82:
 879 005c 011C     		adds	r1, r0, #0
 230:Src/user.cpp  ****                       ((float) adcData[0] - (float) motor.adcValAtAngleMin) /
 880              		.loc 1 230 77 view .LVU259
 881 005e 301C     		adds	r0, r6, #0
 882 0060 FFF7FEFF 		bl	__aeabi_fdiv
 883              	.LVL83:
 884 0064 011C     		adds	r1, r0, #0
 228:Src/user.cpp  ****         motor.angle = motor.mechanicalAngleMin +
 885              		.loc 1 228 48 view .LVU260
 886 0066 381C     		adds	r0, r7, #0
 887 0068 FFF7FEFF 		bl	__aeabi_fadd
 888              	.LVL84:
 889 006c 011C     		adds	r1, r0, #0
 228:Src/user.cpp  ****         motor.angle = motor.mechanicalAngleMin +
 890              		.loc 1 228 21 view .LVU261
 891 006e 2063     		str	r0, [r4, #48]
 234:Src/user.cpp  ****         motor.CalcDceOutput(motor.angle, 0);
 892              		.loc 1 234 9 is_stmt 1 view .LVU262
 234:Src/user.cpp  ****         motor.CalcDceOutput(motor.angle, 0);
 893              		.loc 1 234 28 is_stmt 0 view .LVU263
 894 0070 0022     		movs	r2, #0
 895 0072 2000     		movs	r0, r4
 896 0074 FFF7FEFF 		bl	_ZN5Motor13CalcDceOutputEff
 897              	.LVL85:
 235:Src/user.cpp  ****         motor.SetPwm((int16_t) motor.dce.output);
 898              		.loc 1 235 9 is_stmt 1 view .LVU264
 235:Src/user.cpp  ****         motor.SetPwm((int16_t) motor.dce.output);
 899              		.loc 1 235 21 is_stmt 0 view .LVU265
 900 0078 A06A     		ldr	r0, [r4, #40]
 901 007a FFF7FEFF 		bl	__aeabi_f2iz
 902              	.LVL86:
 903 007e 01B2     		sxth	r1, r0
 904 0080 2000     		movs	r0, r4
 905 0082 FFF7FEFF 		bl	_ZN5Motor6SetPwmEs
 906              	.LVL87:
 907              		.loc 1 237 1 view .LVU266
 908 0086 C2E7     		b	.L39
 909              	.L43:
 910              		.align	2
 911              	.L42:
 912 0088 00200040 		.word	1073750016
 913 008c 00000000 		.word	adcData
 914 0090 00000000 		.word	hadc
 915 0094 00000000 		.word	.LANCHOR0
 916              		.cfi_endproc
 917              	.LFE64:
 918              		.fnend
 920              		.section	.text._ZN6EEPROM3putI8Config_tEERKT_iS4_,"axG",%progbits,_ZN6EEPROM3putI8Config_tEERKT_iS
 921              		.align	1
 922              		.weak	_ZN6EEPROM3putI8Config_tEERKT_iS4_
 923              		.syntax unified
 924              		.code	16
 925              		.thumb_func
 927              	_ZN6EEPROM3putI8Config_tEERKT_iS4_:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 26


 928              		.fnstart
 929              	.LVL88:
 930              	.LFB66:
 931              		.file 3 "Inc/random_flash_interface.h"
   1:Inc/random_flash_interface.h **** #ifndef FlashStorage_STM32_h
   2:Inc/random_flash_interface.h **** #define FlashStorage_STM32_h
   3:Inc/random_flash_interface.h **** 
   4:Inc/random_flash_interface.h **** 
   5:Inc/random_flash_interface.h **** #if !(defined(STM32F0) || defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32
   6:Inc/random_flash_interface.h ****        defined(STM32L0) || defined(STM32L1) || defined(STM32L4) || defined(STM32H7) || defined(STM3
   7:Inc/random_flash_interface.h ****        defined(STM32WB) || defined(STM32MP1) || defined(STM32L5))
   8:Inc/random_flash_interface.h **** #error This code is intended to run on STM32F/L/H/G/WB/MP1 platform! Please check your Tools->Board
   9:Inc/random_flash_interface.h **** #endif
  10:Inc/random_flash_interface.h **** 
  11:Inc/random_flash_interface.h **** // Only use this with emulated EEPROM, without integrated EEPROM
  12:Inc/random_flash_interface.h **** #if !defined(DATA_EEPROM_BASE)
  13:Inc/random_flash_interface.h **** 
  14:Inc/random_flash_interface.h **** #include <cstdint>
  15:Inc/random_flash_interface.h **** #include "random_flash_utils.h"
  16:Inc/random_flash_interface.h **** 
  17:Inc/random_flash_interface.h **** class EEPROM
  18:Inc/random_flash_interface.h **** {
  19:Inc/random_flash_interface.h **** public:
  20:Inc/random_flash_interface.h **** 
  21:Inc/random_flash_interface.h ****     EEPROM() : _initialized(false), _dirtyBuffer(false), _commitASAP(true), _validEEPROM(true)
  22:Inc/random_flash_interface.h ****     {}
  23:Inc/random_flash_interface.h **** 
  24:Inc/random_flash_interface.h ****     /**
  25:Inc/random_flash_interface.h ****      * Read an eeprom cell
  26:Inc/random_flash_interface.h ****      * @param index
  27:Inc/random_flash_interface.h ****      * @return value
  28:Inc/random_flash_interface.h ****      */
  29:Inc/random_flash_interface.h ****     uint8_t read(int address)
  30:Inc/random_flash_interface.h ****     {
  31:Inc/random_flash_interface.h ****         if (!_initialized)
  32:Inc/random_flash_interface.h ****             init();
  33:Inc/random_flash_interface.h **** 
  34:Inc/random_flash_interface.h ****         return eeprom_buffered_read_byte(address);
  35:Inc/random_flash_interface.h ****     }
  36:Inc/random_flash_interface.h **** 
  37:Inc/random_flash_interface.h ****     /**
  38:Inc/random_flash_interface.h ****      * Update an eeprom cell
  39:Inc/random_flash_interface.h ****      * @param index
  40:Inc/random_flash_interface.h ****      * @param value
  41:Inc/random_flash_interface.h ****      */
  42:Inc/random_flash_interface.h ****     void update(int address, uint8_t value)
  43:Inc/random_flash_interface.h ****     {
  44:Inc/random_flash_interface.h ****         if (!_initialized)
  45:Inc/random_flash_interface.h ****             init();
  46:Inc/random_flash_interface.h **** 
  47:Inc/random_flash_interface.h ****         if (eeprom_buffered_read_byte(address) != value)
  48:Inc/random_flash_interface.h ****         {
  49:Inc/random_flash_interface.h ****             _dirtyBuffer = true;
  50:Inc/random_flash_interface.h ****             eeprom_buffered_write_byte(address, value);
  51:Inc/random_flash_interface.h ****         }
  52:Inc/random_flash_interface.h ****     }
  53:Inc/random_flash_interface.h **** 
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 27


  54:Inc/random_flash_interface.h ****     /**
  55:Inc/random_flash_interface.h ****      * Write value to an eeprom cell
  56:Inc/random_flash_interface.h ****      * @param index
  57:Inc/random_flash_interface.h ****      * @param value
  58:Inc/random_flash_interface.h ****      */
  59:Inc/random_flash_interface.h ****     void write(int address, uint8_t value)
  60:Inc/random_flash_interface.h ****     {
  61:Inc/random_flash_interface.h ****         update(address, value);
  62:Inc/random_flash_interface.h ****     }
  63:Inc/random_flash_interface.h **** 
  64:Inc/random_flash_interface.h ****     /**
  65:Inc/random_flash_interface.h ****      * Update eeprom cells from an object
  66:Inc/random_flash_interface.h ****      * @param index
  67:Inc/random_flash_interface.h ****      * @param value
  68:Inc/random_flash_interface.h ****      */
  69:Inc/random_flash_interface.h ****     //Functionality to 'get' and 'put' objects to and from EEPROM.
  70:Inc/random_flash_interface.h ****     template<typename T>
  71:Inc/random_flash_interface.h ****     T &get(int _offset, T &_t)
  72:Inc/random_flash_interface.h ****     {
  73:Inc/random_flash_interface.h ****         // Copy the data from the flash to the buffer if not yet
  74:Inc/random_flash_interface.h ****         if (!_initialized)
  75:Inc/random_flash_interface.h ****             init();
  76:Inc/random_flash_interface.h **** 
  77:Inc/random_flash_interface.h ****         uint16_t offset = _offset;
  78:Inc/random_flash_interface.h ****         uint8_t* _pointer = (uint8_t*) &_t;
  79:Inc/random_flash_interface.h **** 
  80:Inc/random_flash_interface.h ****         for (uint16_t count = sizeof(T); count; --count, ++offset)
  81:Inc/random_flash_interface.h ****         {
  82:Inc/random_flash_interface.h ****             *_pointer++ = eeprom_buffered_read_byte(offset);
  83:Inc/random_flash_interface.h ****         }
  84:Inc/random_flash_interface.h **** 
  85:Inc/random_flash_interface.h ****         return _t;
  86:Inc/random_flash_interface.h ****     }
  87:Inc/random_flash_interface.h **** 
  88:Inc/random_flash_interface.h ****     template<typename T>
  89:Inc/random_flash_interface.h ****     const T &put(int idx, const T &t)
 932              		.loc 3 89 14 is_stmt 1 view -0
 933              		.cfi_startproc
 934              		@ args = 0, pretend = 0, frame = 8
 935              		@ frame_needed = 0, uses_anonymous_args = 0
 936              		.loc 3 89 14 is_stmt 0 view .LVU268
 937 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 938              		.save {r4, r5, r6, r7, lr}
 939              	.LCFI3:
 940              		.cfi_def_cfa_offset 20
 941              		.cfi_offset 4, -20
 942              		.cfi_offset 5, -16
 943              		.cfi_offset 6, -12
 944              		.cfi_offset 7, -8
 945              		.cfi_offset 14, -4
 946              		.pad #12
 947 0002 83B0     		sub	sp, sp, #12
 948              	.LCFI4:
 949              		.cfi_def_cfa_offset 32
 950 0004 0700     		movs	r7, r0
 951 0006 0C00     		movs	r4, r1
 952 0008 0192     		str	r2, [sp, #4]
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 28


  90:Inc/random_flash_interface.h ****     {
  91:Inc/random_flash_interface.h ****         // Copy the data from the flash to the buffer if not yet
  92:Inc/random_flash_interface.h ****         if (!_initialized)
 953              		.loc 3 92 14 view .LVU269
 954 000a 0378     		ldrb	r3, [r0]
 955              		.loc 3 92 9 view .LVU270
 956 000c 002B     		cmp	r3, #0
 957 000e 03D0     		beq	.L50
 958              	.LVL89:
 959              	.L45:
  93:Inc/random_flash_interface.h ****             init();
  94:Inc/random_flash_interface.h **** 
  95:Inc/random_flash_interface.h ****         uint16_t offset = idx;
 960              		.loc 3 95 18 view .LVU271
 961 0010 A4B2     		uxth	r4, r4
 962              	.LVL90:
  96:Inc/random_flash_interface.h **** 
  97:Inc/random_flash_interface.h ****         const uint8_t* _pointer = (const uint8_t*) &t;
 963              		.loc 3 97 24 view .LVU272
 964 0012 019B     		ldr	r3, [sp, #4]
 965              	.LBB54:
  98:Inc/random_flash_interface.h **** 
  99:Inc/random_flash_interface.h ****         for (uint16_t count = sizeof(T); count; --count, ++offset)
 966              		.loc 3 99 23 view .LVU273
 967 0014 3026     		movs	r6, #48
 968 0016 0EE0     		b	.L47
 969              	.LVL91:
 970              	.L50:
 971              		.loc 3 99 23 view .LVU274
 972              	.LBE54:
 973              	.LBB55:
 974              	.LBI55:
 100:Inc/random_flash_interface.h ****         {
 101:Inc/random_flash_interface.h ****             eeprom_buffered_write_byte(offset, *_pointer++);
 102:Inc/random_flash_interface.h ****         }
 103:Inc/random_flash_interface.h **** 
 104:Inc/random_flash_interface.h ****         if (_commitASAP)
 105:Inc/random_flash_interface.h ****         {
 106:Inc/random_flash_interface.h ****             // Save the data from the buffer to the flash right away
 107:Inc/random_flash_interface.h ****             eeprom_buffer_flush();
 108:Inc/random_flash_interface.h **** 
 109:Inc/random_flash_interface.h ****             _dirtyBuffer = false;
 110:Inc/random_flash_interface.h ****             _validEEPROM = true;
 111:Inc/random_flash_interface.h ****         } else
 112:Inc/random_flash_interface.h ****         {
 113:Inc/random_flash_interface.h ****             // Delay saving the data from the buffer to the flash. Just flag and wait for commit() 
 114:Inc/random_flash_interface.h ****             _dirtyBuffer = true;
 115:Inc/random_flash_interface.h ****         }
 116:Inc/random_flash_interface.h **** 
 117:Inc/random_flash_interface.h ****         return t;
 118:Inc/random_flash_interface.h ****     }
 119:Inc/random_flash_interface.h **** 
 120:Inc/random_flash_interface.h ****     /**
 121:Inc/random_flash_interface.h ****      * Check whether the eeprom data is valid
 122:Inc/random_flash_interface.h ****      * @return true, if eeprom data is valid (has been written at least once), false if not
 123:Inc/random_flash_interface.h ****      */
 124:Inc/random_flash_interface.h ****     bool isValid()
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 29


 125:Inc/random_flash_interface.h ****     {
 126:Inc/random_flash_interface.h ****         return _validEEPROM;
 127:Inc/random_flash_interface.h ****     }
 128:Inc/random_flash_interface.h **** 
 129:Inc/random_flash_interface.h ****     /**
 130:Inc/random_flash_interface.h ****      * Write previously made eeprom changes to the underlying flash storage
 131:Inc/random_flash_interface.h ****      * Use this with care: Each and every commit will harm the flash and reduce it's lifetime (like
 132:Inc/random_flash_interface.h ****      */
 133:Inc/random_flash_interface.h ****     void commit()
 134:Inc/random_flash_interface.h ****     {
 135:Inc/random_flash_interface.h ****         if (!_initialized)
 136:Inc/random_flash_interface.h ****             init();
 137:Inc/random_flash_interface.h **** 
 138:Inc/random_flash_interface.h ****         if (_dirtyBuffer)
 139:Inc/random_flash_interface.h ****         {
 140:Inc/random_flash_interface.h ****             // Save the data from the buffer to the flash
 141:Inc/random_flash_interface.h ****             eeprom_buffer_flush();
 142:Inc/random_flash_interface.h **** 
 143:Inc/random_flash_interface.h ****             _dirtyBuffer = false;
 144:Inc/random_flash_interface.h ****             _validEEPROM = true;
 145:Inc/random_flash_interface.h ****         }
 146:Inc/random_flash_interface.h ****     }
 147:Inc/random_flash_interface.h **** 
 148:Inc/random_flash_interface.h ****     uint16_t length()
 149:Inc/random_flash_interface.h ****     { return E2END + 1; }
 150:Inc/random_flash_interface.h **** 
 151:Inc/random_flash_interface.h ****     void setCommitASAP(bool value = true)
 152:Inc/random_flash_interface.h ****     { _commitASAP = value; }
 153:Inc/random_flash_interface.h ****     bool getCommitASAP()
 154:Inc/random_flash_interface.h ****     { return _commitASAP; }
 155:Inc/random_flash_interface.h **** 
 156:Inc/random_flash_interface.h **** private:
 157:Inc/random_flash_interface.h **** 
 158:Inc/random_flash_interface.h ****     void init()
 975              		.loc 3 158 10 is_stmt 1 view .LVU275
 976              	.LBB56:
 159:Inc/random_flash_interface.h ****     {
 160:Inc/random_flash_interface.h ****         // Copy the data from the flash to the buffer
 161:Inc/random_flash_interface.h ****         eeprom_buffer_fill();
 977              		.loc 3 161 9 view .LVU276
 978              		.loc 3 161 27 is_stmt 0 view .LVU277
 979 0018 FFF7FEFF 		bl	eeprom_buffer_fill
 980              	.LVL92:
 162:Inc/random_flash_interface.h ****         _initialized = true;
 981              		.loc 3 162 9 is_stmt 1 view .LVU278
 982              		.loc 3 162 22 is_stmt 0 view .LVU279
 983 001c 0123     		movs	r3, #1
 984 001e 3B70     		strb	r3, [r7]
 163:Inc/random_flash_interface.h ****     }
 985              		.loc 3 163 5 view .LVU280
 986 0020 F6E7     		b	.L45
 987              	.LVL93:
 988              	.L51:
 989              		.loc 3 163 5 view .LVU281
 990              	.LBE56:
 991              	.LBE55:
 992              	.LBB57:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 30


 101:Inc/random_flash_interface.h ****         }
 993              		.loc 3 101 39 discriminator 2 view .LVU282
 994 0022 5D1C     		adds	r5, r3, #1
 995              	.LVL94:
 101:Inc/random_flash_interface.h ****         }
 996              		.loc 3 101 39 discriminator 2 view .LVU283
 997 0024 1978     		ldrb	r1, [r3]
 998 0026 2000     		movs	r0, r4
 999 0028 FFF7FEFF 		bl	eeprom_buffered_write_byte
 1000              	.LVL95:
  99:Inc/random_flash_interface.h ****         {
 1001              		.loc 3 99 9 is_stmt 1 discriminator 2 view .LVU284
 1002 002c 013E     		subs	r6, r6, #1
 1003              	.LVL96:
  99:Inc/random_flash_interface.h ****         {
 1004              		.loc 3 99 9 is_stmt 0 discriminator 2 view .LVU285
 1005 002e B6B2     		uxth	r6, r6
 1006              	.LVL97:
  99:Inc/random_flash_interface.h ****         {
 1007              		.loc 3 99 9 discriminator 2 view .LVU286
 1008 0030 0134     		adds	r4, r4, #1
 1009              	.LVL98:
  99:Inc/random_flash_interface.h ****         {
 1010              		.loc 3 99 9 discriminator 2 view .LVU287
 1011 0032 A4B2     		uxth	r4, r4
 1012              	.LVL99:
 101:Inc/random_flash_interface.h ****         }
 1013              		.loc 3 101 39 discriminator 2 view .LVU288
 1014 0034 2B00     		movs	r3, r5
 1015              	.LVL100:
 1016              	.L47:
  99:Inc/random_flash_interface.h ****         {
 1017              		.loc 3 99 42 is_stmt 1 discriminator 3 view .LVU289
 1018 0036 002E     		cmp	r6, #0
 1019 0038 F3D1     		bne	.L51
  99:Inc/random_flash_interface.h ****         {
 1020              		.loc 3 99 42 is_stmt 0 discriminator 3 view .LVU290
 1021              	.LBE57:
 104:Inc/random_flash_interface.h ****         {
 1022              		.loc 3 104 13 view .LVU291
 1023 003a BB78     		ldrb	r3, [r7, #2]
 1024              	.LVL101:
 104:Inc/random_flash_interface.h ****         {
 1025              		.loc 3 104 9 view .LVU292
 1026 003c 002B     		cmp	r3, #0
 1027 003e 04D1     		bne	.L52
 114:Inc/random_flash_interface.h ****         }
 1028              		.loc 3 114 26 view .LVU293
 1029 0040 0123     		movs	r3, #1
 1030 0042 7B70     		strb	r3, [r7, #1]
 1031              	.L49:
 118:Inc/random_flash_interface.h **** 
 1032              		.loc 3 118 5 view .LVU294
 1033 0044 0198     		ldr	r0, [sp, #4]
 1034 0046 03B0     		add	sp, sp, #12
 1035              		@ sp needed
 1036              	.LVL102:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 31


 1037              	.LVL103:
 1038              	.LVL104:
 118:Inc/random_flash_interface.h **** 
 1039              		.loc 3 118 5 view .LVU295
 1040 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
 1041              	.LVL105:
 1042              	.L52:
 107:Inc/random_flash_interface.h **** 
 1043              		.loc 3 107 32 view .LVU296
 1044 004a FFF7FEFF 		bl	eeprom_buffer_flush
 1045              	.LVL106:
 109:Inc/random_flash_interface.h ****             _validEEPROM = true;
 1046              		.loc 3 109 26 view .LVU297
 1047 004e 0023     		movs	r3, #0
 1048 0050 7B70     		strb	r3, [r7, #1]
 110:Inc/random_flash_interface.h ****         } else
 1049              		.loc 3 110 26 view .LVU298
 1050 0052 0133     		adds	r3, r3, #1
 1051 0054 FB70     		strb	r3, [r7, #3]
 1052 0056 F5E7     		b	.L49
 1053              		.cfi_endproc
 1054              	.LFE66:
 1055              		.fnend
 1057              		.section	.text.Main,"ax",%progbits
 1058              		.align	1
 1059              		.global	Main
 1060              		.syntax unified
 1061              		.code	16
 1062              		.thumb_func
 1064              	Main:
 1065              		.fnstart
 1066              	.LFB62:
  11:Src/user.cpp  **** {
 1067              		.loc 1 11 1 is_stmt 1 view -0
 1068              		.cfi_startproc
 1069              		@ args = 0, pretend = 0, frame = 8
 1070              		@ frame_needed = 0, uses_anonymous_args = 0
 1071 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1072              		.save {r4, r5, r6, r7, lr}
 1073              	.LCFI5:
 1074              		.cfi_def_cfa_offset 20
 1075              		.cfi_offset 4, -20
 1076              		.cfi_offset 5, -16
 1077              		.cfi_offset 6, -12
 1078              		.cfi_offset 7, -8
 1079              		.cfi_offset 14, -4
 1080              		.pad #12
 1081 0002 83B0     		sub	sp, sp, #12
 1082              	.LCFI6:
 1083              		.cfi_def_cfa_offset 32
  13:Src/user.cpp  ****     EEPROM eeprom;
 1084              		.loc 1 13 5 view .LVU300
 1085              	.LVL107:
 1086              	.LBB77:
 1087              	.LBI77:
  21:Inc/random_flash_interface.h ****     {}
 1088              		.loc 3 21 5 view .LVU301
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 32


 1089              	.LBB78:
 1090              	.LBB79:
  21:Inc/random_flash_interface.h ****     {}
 1091              		.loc 3 21 94 is_stmt 0 view .LVU302
 1092 0004 01AB     		add	r3, sp, #4
 1093              	.LVL108:
  21:Inc/random_flash_interface.h ****     {}
 1094              		.loc 3 21 94 view .LVU303
 1095 0006 0022     		movs	r2, #0
 1096 0008 1A70     		strb	r2, [r3]
 1097 000a 5A70     		strb	r2, [r3, #1]
 1098 000c 0132     		adds	r2, r2, #1
 1099 000e 9A70     		strb	r2, [r3, #2]
 1100 0010 DA70     		strb	r2, [r3, #3]
 1101              	.LVL109:
  21:Inc/random_flash_interface.h ****     {}
 1102              		.loc 3 21 94 view .LVU304
 1103              	.LBE79:
 1104              	.LBE78:
 1105              	.LBE77:
  14:Src/user.cpp  ****     eeprom.get(0, boardConfig);
 1106              		.loc 1 14 5 is_stmt 1 view .LVU305
 1107              	.LBB80:
 1108              	.LBI80:
  71:Inc/random_flash_interface.h ****     {
 1109              		.loc 3 71 8 view .LVU306
 1110              	.LBB81:
 1111              	.LBB82:
 1112              	.LBI82:
 158:Inc/random_flash_interface.h ****     {
 1113              		.loc 3 158 10 view .LVU307
 1114              	.LBB83:
 161:Inc/random_flash_interface.h ****         _initialized = true;
 1115              		.loc 3 161 9 view .LVU308
 161:Inc/random_flash_interface.h ****         _initialized = true;
 1116              		.loc 3 161 27 is_stmt 0 view .LVU309
 1117 0012 FFF7FEFF 		bl	eeprom_buffer_fill
 1118              	.LVL110:
 162:Inc/random_flash_interface.h ****     }
 1119              		.loc 3 162 9 is_stmt 1 view .LVU310
 162:Inc/random_flash_interface.h ****     }
 1120              		.loc 3 162 22 is_stmt 0 view .LVU311
 1121 0016 01AB     		add	r3, sp, #4
 1122              	.LVL111:
 162:Inc/random_flash_interface.h ****     }
 1123              		.loc 3 162 22 view .LVU312
 1124 0018 0122     		movs	r2, #1
 1125 001a 1A70     		strb	r2, [r3]
 1126              	.LVL112:
 162:Inc/random_flash_interface.h ****     }
 1127              		.loc 3 162 22 view .LVU313
 1128              	.LBE83:
 1129              	.LBE82:
 1130              	.LBB84:
  80:Inc/random_flash_interface.h ****         {
 1131              		.loc 3 80 23 view .LVU314
 1132 001c 3026     		movs	r6, #48
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 33


 1133              	.LBE84:
  78:Inc/random_flash_interface.h **** 
 1134              		.loc 3 78 18 view .LVU315
 1135 001e 4E4D     		ldr	r5, .L72
  77:Inc/random_flash_interface.h ****         uint8_t* _pointer = (uint8_t*) &_t;
 1136              		.loc 3 77 18 view .LVU316
 1137 0020 0024     		movs	r4, #0
 1138              	.LVL113:
 1139              	.L56:
 1140              	.LBB85:
  80:Inc/random_flash_interface.h ****         {
 1141              		.loc 3 80 42 is_stmt 1 view .LVU317
 1142 0022 002E     		cmp	r6, #0
 1143 0024 0AD0     		beq	.L55
  82:Inc/random_flash_interface.h ****         }
 1144              		.loc 3 82 25 is_stmt 0 view .LVU318
 1145 0026 6F1C     		adds	r7, r5, #1
 1146              	.LVL114:
  82:Inc/random_flash_interface.h ****         }
 1147              		.loc 3 82 52 view .LVU319
 1148 0028 2000     		movs	r0, r4
 1149 002a FFF7FEFF 		bl	eeprom_buffered_read_byte
 1150              	.LVL115:
  82:Inc/random_flash_interface.h ****         }
 1151              		.loc 3 82 25 view .LVU320
 1152 002e 2870     		strb	r0, [r5]
  80:Inc/random_flash_interface.h ****         {
 1153              		.loc 3 80 9 is_stmt 1 view .LVU321
 1154 0030 013E     		subs	r6, r6, #1
 1155              	.LVL116:
  80:Inc/random_flash_interface.h ****         {
 1156              		.loc 3 80 9 is_stmt 0 view .LVU322
 1157 0032 B6B2     		uxth	r6, r6
 1158              	.LVL117:
  80:Inc/random_flash_interface.h ****         {
 1159              		.loc 3 80 9 view .LVU323
 1160 0034 0134     		adds	r4, r4, #1
 1161              	.LVL118:
  80:Inc/random_flash_interface.h ****         {
 1162              		.loc 3 80 9 view .LVU324
 1163 0036 A4B2     		uxth	r4, r4
 1164              	.LVL119:
  82:Inc/random_flash_interface.h ****         }
 1165              		.loc 3 82 25 view .LVU325
 1166 0038 3D00     		movs	r5, r7
  80:Inc/random_flash_interface.h ****         {
 1167              		.loc 3 80 9 view .LVU326
 1168 003a F2E7     		b	.L56
 1169              	.LVL120:
 1170              	.L55:
  80:Inc/random_flash_interface.h ****         {
 1171              		.loc 3 80 9 view .LVU327
 1172              	.LBE85:
 1173              	.LBE81:
 1174              	.LBE80:
  15:Src/user.cpp  ****     if (boardConfig.configStatus != CONFIG_OK) // use default settings
 1175              		.loc 1 15 5 is_stmt 1 view .LVU328
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 34


  15:Src/user.cpp  ****     if (boardConfig.configStatus != CONFIG_OK) // use default settings
 1176              		.loc 1 15 21 is_stmt 0 view .LVU329
 1177 003c 464B     		ldr	r3, .L72
 1178 003e 1B78     		ldrb	r3, [r3]
  15:Src/user.cpp  ****     if (boardConfig.configStatus != CONFIG_OK) // use default settings
 1179              		.loc 1 15 5 view .LVU330
 1180 0040 012B     		cmp	r3, #1
 1181 0042 38D1     		bne	.L67
 1182              	.L57:
  35:Src/user.cpp  ****     motor.SetTorqueLimit(boardConfig.toqueLimit);
 1183              		.loc 1 35 5 is_stmt 1 view .LVU331
  35:Src/user.cpp  ****     motor.SetTorqueLimit(boardConfig.toqueLimit);
 1184              		.loc 1 35 25 is_stmt 0 view .LVU332
 1185 0044 444C     		ldr	r4, .L72
 1186 0046 454D     		ldr	r5, .L72+4
 1187 0048 A168     		ldr	r1, [r4, #8]
 1188 004a 2800     		movs	r0, r5
 1189 004c FFF7FEFF 		bl	_ZN5Motor14SetTorqueLimitEf
 1190              	.LVL121:
  36:Src/user.cpp  ****     motor.mechanicalAngleMin = boardConfig.mechanicalAngleMin;
 1191              		.loc 1 36 5 is_stmt 1 view .LVU333
  36:Src/user.cpp  ****     motor.mechanicalAngleMin = boardConfig.mechanicalAngleMin;
 1192              		.loc 1 36 30 is_stmt 0 view .LVU334
 1193 0050 6369     		ldr	r3, [r4, #20]
 1194 0052 AB63     		str	r3, [r5, #56]
  37:Src/user.cpp  ****     motor.mechanicalAngleMax = boardConfig.mechanicalAngleMax;
 1195              		.loc 1 37 5 is_stmt 1 view .LVU335
  37:Src/user.cpp  ****     motor.mechanicalAngleMax = boardConfig.mechanicalAngleMax;
 1196              		.loc 1 37 30 is_stmt 0 view .LVU336
 1197 0054 A369     		ldr	r3, [r4, #24]
 1198 0056 EB63     		str	r3, [r5, #60]
  38:Src/user.cpp  ****     motor.adcValAtAngleMin = boardConfig.adcValAtAngleMin;
 1199              		.loc 1 38 5 is_stmt 1 view .LVU337
  38:Src/user.cpp  ****     motor.adcValAtAngleMin = boardConfig.adcValAtAngleMin;
 1200              		.loc 1 38 42 is_stmt 0 view .LVU338
 1201 0058 238A     		ldrh	r3, [r4, #16]
  38:Src/user.cpp  ****     motor.adcValAtAngleMin = boardConfig.adcValAtAngleMin;
 1202              		.loc 1 38 28 view .LVU339
 1203 005a AB85     		strh	r3, [r5, #44]
  39:Src/user.cpp  ****     motor.adcValAtAngleMax = boardConfig.adcValAtAngleMax;
 1204              		.loc 1 39 5 is_stmt 1 view .LVU340
  39:Src/user.cpp  ****     motor.adcValAtAngleMax = boardConfig.adcValAtAngleMax;
 1205              		.loc 1 39 42 is_stmt 0 view .LVU341
 1206 005c 638A     		ldrh	r3, [r4, #18]
  39:Src/user.cpp  ****     motor.adcValAtAngleMax = boardConfig.adcValAtAngleMax;
 1207              		.loc 1 39 28 view .LVU342
 1208 005e EB85     		strh	r3, [r5, #46]
  40:Src/user.cpp  ****     motor.dce.kp = boardConfig.dceKp;
 1209              		.loc 1 40 5 is_stmt 1 view .LVU343
  40:Src/user.cpp  ****     motor.dce.kp = boardConfig.dceKp;
 1210              		.loc 1 40 18 is_stmt 0 view .LVU344
 1211 0060 E369     		ldr	r3, [r4, #28]
 1212 0062 6B60     		str	r3, [r5, #4]
  41:Src/user.cpp  ****     motor.dce.ki = boardConfig.dceKi;
 1213              		.loc 1 41 5 is_stmt 1 view .LVU345
  41:Src/user.cpp  ****     motor.dce.ki = boardConfig.dceKi;
 1214              		.loc 1 41 18 is_stmt 0 view .LVU346
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 35


 1215 0064 636A     		ldr	r3, [r4, #36]
 1216 0066 EB60     		str	r3, [r5, #12]
  42:Src/user.cpp  ****     motor.dce.kv = boardConfig.dceKv;
 1217              		.loc 1 42 5 is_stmt 1 view .LVU347
  42:Src/user.cpp  ****     motor.dce.kv = boardConfig.dceKv;
 1218              		.loc 1 42 18 is_stmt 0 view .LVU348
 1219 0068 236A     		ldr	r3, [r4, #32]
 1220 006a AB60     		str	r3, [r5, #8]
  43:Src/user.cpp  ****     motor.dce.kd = boardConfig.dceKd;
 1221              		.loc 1 43 5 is_stmt 1 view .LVU349
  43:Src/user.cpp  ****     motor.dce.kd = boardConfig.dceKd;
 1222              		.loc 1 43 18 is_stmt 0 view .LVU350
 1223 006c A36A     		ldr	r3, [r4, #40]
 1224 006e 2B61     		str	r3, [r5, #16]
  44:Src/user.cpp  ****     motor.dce.setPointPos = boardConfig.initPos;
 1225              		.loc 1 44 5 is_stmt 1 view .LVU351
  44:Src/user.cpp  ****     motor.dce.setPointPos = boardConfig.initPos;
 1226              		.loc 1 44 27 is_stmt 0 view .LVU352
 1227 0070 6368     		ldr	r3, [r4, #4]
 1228 0072 6B61     		str	r3, [r5, #20]
  45:Src/user.cpp  ****     motor.SetEnable(boardConfig.enableMotorOnBoot);
 1229              		.loc 1 45 5 is_stmt 1 view .LVU353
  45:Src/user.cpp  ****     motor.SetEnable(boardConfig.enableMotorOnBoot);
 1230              		.loc 1 45 20 is_stmt 0 view .LVU354
 1231 0074 2C23     		movs	r3, #44
 1232 0076 E15C     		ldrb	r1, [r4, r3]
 1233 0078 2800     		movs	r0, r5
 1234 007a FFF7FEFF 		bl	_ZN5Motor9SetEnableEb
 1235              	.LVL122:
  47:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
 1236              		.loc 1 47 5 is_stmt 1 view .LVU355
  47:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
 1237              		.loc 1 47 22 is_stmt 0 view .LVU356
 1238 007e 384D     		ldr	r5, .L72+8
 1239 0080 0021     		movs	r1, #0
 1240 0082 2800     		movs	r0, r5
 1241 0084 FFF7FEFF 		bl	HAL_TIM_PWM_Start
 1242              	.LVL123:
  48:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
 1243              		.loc 1 48 5 is_stmt 1 view .LVU357
  48:Src/user.cpp  ****     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
 1244              		.loc 1 48 22 is_stmt 0 view .LVU358
 1245 0088 0421     		movs	r1, #4
 1246 008a 2800     		movs	r0, r5
 1247 008c FFF7FEFF 		bl	HAL_TIM_PWM_Start
 1248              	.LVL124:
  49:Src/user.cpp  ****     __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 0);
 1249              		.loc 1 49 5 is_stmt 1 view .LVU359
 1250 0090 2B68     		ldr	r3, [r5]
 1251 0092 0022     		movs	r2, #0
 1252 0094 5A63     		str	r2, [r3, #52]
  50:Src/user.cpp  ****     __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, 0);
 1253              		.loc 1 50 5 view .LVU360
 1254 0096 9A63     		str	r2, [r3, #56]
  53:Src/user.cpp  ****     MY_I2C1_Init(boardConfig.nodeId);
 1255              		.loc 1 53 5 view .LVU361
  53:Src/user.cpp  ****     MY_I2C1_Init(boardConfig.nodeId);
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 36


 1256              		.loc 1 53 30 is_stmt 0 view .LVU362
 1257 0098 6078     		ldrb	r0, [r4, #1]
  53:Src/user.cpp  ****     MY_I2C1_Init(boardConfig.nodeId);
 1258              		.loc 1 53 17 view .LVU363
 1259 009a FFF7FEFF 		bl	MY_I2C1_Init
 1260              	.LVL125:
  54:Src/user.cpp  ****     HAL_Delay(10);
 1261              		.loc 1 54 5 is_stmt 1 view .LVU364
  54:Src/user.cpp  ****     HAL_Delay(10);
 1262              		.loc 1 54 14 is_stmt 0 view .LVU365
 1263 009e 0A20     		movs	r0, #10
 1264 00a0 FFF7FEFF 		bl	HAL_Delay
 1265              	.LVL126:
  55:Src/user.cpp  ****     HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 1266              		.loc 1 55 5 is_stmt 1 view .LVU366
  55:Src/user.cpp  ****     HAL_I2C_Slave_Receive_IT(&hi2c1, (uint8_t*) i2cDataRx, 5);
 1267              		.loc 1 55 29 is_stmt 0 view .LVU367
 1268 00a4 0522     		movs	r2, #5
 1269 00a6 2F49     		ldr	r1, .L72+12
 1270 00a8 2F48     		ldr	r0, .L72+16
 1271 00aa FFF7FEFF 		bl	HAL_I2C_Slave_Receive_IT
 1272              	.LVL127:
  58:Src/user.cpp  ****     HAL_TIM_Base_Start_IT(&htim14);
 1273              		.loc 1 58 5 is_stmt 1 view .LVU368
  58:Src/user.cpp  ****     HAL_TIM_Base_Start_IT(&htim14);
 1274              		.loc 1 58 26 is_stmt 0 view .LVU369
 1275 00ae 2F48     		ldr	r0, .L72+20
 1276 00b0 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1277              	.LVL128:
 1278 00b4 33E0     		b	.L58
 1279              	.L67:
  17:Src/user.cpp  ****         boardConfig = BoardConfig_t{
 1280              		.loc 1 17 9 is_stmt 1 view .LVU370
  17:Src/user.cpp  ****         boardConfig = BoardConfig_t{
 1281              		.loc 1 17 21 is_stmt 0 view .LVU371
 1282 00b6 284A     		ldr	r2, .L72
 1283 00b8 2D4B     		ldr	r3, .L72+24
 1284 00ba 1100     		movs	r1, r2
 1285 00bc 31CB     		ldmia	r3!, {r0, r4, r5}
 1286 00be 31C1     		stmia	r1!, {r0, r4, r5}
 1287 00c0 31CB     		ldmia	r3!, {r0, r4, r5}
 1288 00c2 31C1     		stmia	r1!, {r0, r4, r5}
 1289 00c4 31CB     		ldmia	r3!, {r0, r4, r5}
 1290 00c6 31C1     		stmia	r1!, {r0, r4, r5}
 1291 00c8 31CB     		ldmia	r3!, {r0, r4, r5}
 1292 00ca 31C1     		stmia	r1!, {r0, r4, r5}
  33:Src/user.cpp  ****         eeprom.put(0, boardConfig);
 1293              		.loc 1 33 9 is_stmt 1 view .LVU372
  33:Src/user.cpp  ****         eeprom.put(0, boardConfig);
 1294              		.loc 1 33 34 is_stmt 0 view .LVU373
 1295 00cc 0021     		movs	r1, #0
 1296 00ce 01A8     		add	r0, sp, #4
 1297 00d0 FFF7FEFF 		bl	_ZN6EEPROM3putI8Config_tEERKT_iS4_
 1298              	.LVL129:
 1299 00d4 B6E7     		b	.L57
 1300              	.L71:
  65:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_OK;
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 37


 1301              		.loc 1 65 13 is_stmt 1 view .LVU374
  65:Src/user.cpp  ****             boardConfig.configStatus = CONFIG_OK;
 1302              		.loc 1 65 38 is_stmt 0 view .LVU375
 1303 00d6 204B     		ldr	r3, .L72
 1304 00d8 0122     		movs	r2, #1
 1305 00da 1A70     		strb	r2, [r3]
  66:Src/user.cpp  ****             eeprom.put(0, boardConfig);
 1306              		.loc 1 66 13 is_stmt 1 view .LVU376
 1307              	.LVL130:
 1308              	.LBB86:
 1309              	.LBI86:
  89:Inc/random_flash_interface.h ****     {
 1310              		.loc 3 89 14 view .LVU377
 1311              	.LBB87:
  92:Inc/random_flash_interface.h ****             init();
 1312              		.loc 3 92 14 is_stmt 0 view .LVU378
 1313 00dc 01AB     		add	r3, sp, #4
 1314              	.LVL131:
  92:Inc/random_flash_interface.h ****             init();
 1315              		.loc 3 92 14 view .LVU379
 1316 00de 1B78     		ldrb	r3, [r3]
 1317              	.LVL132:
  92:Inc/random_flash_interface.h ****             init();
 1318              		.loc 3 92 9 view .LVU380
 1319 00e0 002B     		cmp	r3, #0
 1320 00e2 03D0     		beq	.L68
 1321              	.L60:
 1322              	.LVL133:
  95:Inc/random_flash_interface.h **** 
 1323              		.loc 3 95 18 view .LVU381
 1324 00e4 3500     		movs	r5, r6
 1325              	.LBB88:
  99:Inc/random_flash_interface.h ****         {
 1326              		.loc 3 99 23 view .LVU382
 1327 00e6 3024     		movs	r4, #48
 1328              	.LBE88:
  97:Inc/random_flash_interface.h **** 
 1329              		.loc 3 97 24 view .LVU383
 1330 00e8 1B4B     		ldr	r3, .L72
 1331 00ea 0FE0     		b	.L62
 1332              	.LVL134:
 1333              	.L68:
 1334              	.LBB89:
 1335              	.LBI89:
 158:Inc/random_flash_interface.h ****     {
 1336              		.loc 3 158 10 is_stmt 1 view .LVU384
 1337              	.LBB90:
 161:Inc/random_flash_interface.h ****         _initialized = true;
 1338              		.loc 3 161 9 view .LVU385
 161:Inc/random_flash_interface.h ****         _initialized = true;
 1339              		.loc 3 161 27 is_stmt 0 view .LVU386
 1340 00ec FFF7FEFF 		bl	eeprom_buffer_fill
 1341              	.LVL135:
 162:Inc/random_flash_interface.h ****     }
 1342              		.loc 3 162 9 is_stmt 1 view .LVU387
 162:Inc/random_flash_interface.h ****     }
 1343              		.loc 3 162 22 is_stmt 0 view .LVU388
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 38


 1344 00f0 01AB     		add	r3, sp, #4
 1345              	.LVL136:
 162:Inc/random_flash_interface.h ****     }
 1346              		.loc 3 162 22 view .LVU389
 1347 00f2 0122     		movs	r2, #1
 1348 00f4 1A70     		strb	r2, [r3]
 1349              		.loc 3 163 5 view .LVU390
 1350 00f6 F5E7     		b	.L60
 1351              	.LVL137:
 1352              	.L69:
 1353              		.loc 3 163 5 view .LVU391
 1354              	.LBE90:
 1355              	.LBE89:
 1356              	.LBB91:
 101:Inc/random_flash_interface.h ****         }
 1357              		.loc 3 101 39 view .LVU392
 1358 00f8 5F1C     		adds	r7, r3, #1
 1359              	.LVL138:
 101:Inc/random_flash_interface.h ****         }
 1360              		.loc 3 101 39 view .LVU393
 1361 00fa 1978     		ldrb	r1, [r3]
 1362 00fc 2800     		movs	r0, r5
 1363 00fe FFF7FEFF 		bl	eeprom_buffered_write_byte
 1364              	.LVL139:
  99:Inc/random_flash_interface.h ****         {
 1365              		.loc 3 99 9 is_stmt 1 view .LVU394
 1366 0102 013C     		subs	r4, r4, #1
 1367              	.LVL140:
  99:Inc/random_flash_interface.h ****         {
 1368              		.loc 3 99 9 is_stmt 0 view .LVU395
 1369 0104 A4B2     		uxth	r4, r4
 1370              	.LVL141:
  99:Inc/random_flash_interface.h ****         {
 1371              		.loc 3 99 9 view .LVU396
 1372 0106 0135     		adds	r5, r5, #1
 1373              	.LVL142:
  99:Inc/random_flash_interface.h ****         {
 1374              		.loc 3 99 9 view .LVU397
 1375 0108 ADB2     		uxth	r5, r5
 1376              	.LVL143:
 101:Inc/random_flash_interface.h ****         }
 1377              		.loc 3 101 39 view .LVU398
 1378 010a 3B00     		movs	r3, r7
 1379              	.LVL144:
 1380              	.L62:
  99:Inc/random_flash_interface.h ****         {
 1381              		.loc 3 99 42 is_stmt 1 view .LVU399
 1382 010c 002C     		cmp	r4, #0
 1383 010e F3D1     		bne	.L69
 1384              	.LBE91:
 104:Inc/random_flash_interface.h ****         {
 1385              		.loc 3 104 13 is_stmt 0 view .LVU400
 1386 0110 01AB     		add	r3, sp, #4
 1387              	.LVL145:
 104:Inc/random_flash_interface.h ****         {
 1388              		.loc 3 104 13 view .LVU401
 1389 0112 9B78     		ldrb	r3, [r3, #2]
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 39


 1390              	.LVL146:
 104:Inc/random_flash_interface.h ****         {
 1391              		.loc 3 104 9 view .LVU402
 1392 0114 002B     		cmp	r3, #0
 1393 0116 16D1     		bne	.L70
 114:Inc/random_flash_interface.h ****         }
 1394              		.loc 3 114 26 view .LVU403
 1395 0118 01AB     		add	r3, sp, #4
 1396              	.LVL147:
 114:Inc/random_flash_interface.h ****         }
 1397              		.loc 3 114 26 view .LVU404
 1398 011a 0122     		movs	r2, #1
 1399 011c 5A70     		strb	r2, [r3, #1]
 1400              	.LVL148:
 1401              	.L58:
 114:Inc/random_flash_interface.h ****         }
 1402              		.loc 3 114 26 view .LVU405
 1403              	.LBE87:
 1404              	.LBE86:
  61:Src/user.cpp  ****     while (1)
 1405              		.loc 1 61 5 is_stmt 1 view .LVU406
  63:Src/user.cpp  ****         if (boardConfig.configStatus == CONFIG_COMMIT)
 1406              		.loc 1 63 9 view .LVU407
  63:Src/user.cpp  ****         if (boardConfig.configStatus == CONFIG_COMMIT)
 1407              		.loc 1 63 25 is_stmt 0 view .LVU408
 1408 011e 0E4B     		ldr	r3, .L72
 1409 0120 1B78     		ldrb	r3, [r3]
  63:Src/user.cpp  ****         if (boardConfig.configStatus == CONFIG_COMMIT)
 1410              		.loc 1 63 9 view .LVU409
 1411 0122 022B     		cmp	r3, #2
 1412 0124 D7D0     		beq	.L71
  67:Src/user.cpp  ****         } else if (boardConfig.configStatus == CONFIG_RESTORE)
 1413              		.loc 1 67 16 is_stmt 1 view .LVU410
 1414 0126 002B     		cmp	r3, #0
 1415 0128 F9D1     		bne	.L58
  69:Src/user.cpp  ****             eeprom.put(0, boardConfig);
 1416              		.loc 1 69 13 view .LVU411
  69:Src/user.cpp  ****             eeprom.put(0, boardConfig);
 1417              		.loc 1 69 38 is_stmt 0 view .LVU412
 1418 012a 0B4A     		ldr	r2, .L72
 1419 012c 0021     		movs	r1, #0
 1420 012e 01A8     		add	r0, sp, #4
 1421 0130 FFF7FEFF 		bl	_ZN6EEPROM3putI8Config_tEERKT_iS4_
 1422              	.LVL149:
  70:Src/user.cpp  ****             NVIC_SystemReset();
 1423              		.loc 1 70 13 is_stmt 1 view .LVU413
 1424              	.LBB93:
 1425              	.LBI93:
 1426              		.file 4 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 40


   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 41


  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 42


 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 43


 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 44


 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 45


 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 46


 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 47


 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 48


 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 49


 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 50


 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 51


 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 52


 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 735:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 736:Drivers/CMSIS/Include/core_cm0.h ****   }
 737:Drivers/CMSIS/Include/core_cm0.h ****   else
 738:Drivers/CMSIS/Include/core_cm0.h ****   {
 739:Drivers/CMSIS/Include/core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 740:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 741:Drivers/CMSIS/Include/core_cm0.h ****   }
 742:Drivers/CMSIS/Include/core_cm0.h **** }
 743:Drivers/CMSIS/Include/core_cm0.h **** 
 744:Drivers/CMSIS/Include/core_cm0.h **** 
 745:Drivers/CMSIS/Include/core_cm0.h **** /**
 746:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Priority
 747:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the priority of a device specific interrupt or a processor exception.
 748:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 749:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 53


 750:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn  Interrupt number.
 751:Drivers/CMSIS/Include/core_cm0.h ****   \return             Interrupt Priority.
 752:Drivers/CMSIS/Include/core_cm0.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 753:Drivers/CMSIS/Include/core_cm0.h ****  */
 754:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
 755:Drivers/CMSIS/Include/core_cm0.h **** {
 756:Drivers/CMSIS/Include/core_cm0.h **** 
 757:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 758:Drivers/CMSIS/Include/core_cm0.h ****   {
 759:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 760:Drivers/CMSIS/Include/core_cm0.h ****   }
 761:Drivers/CMSIS/Include/core_cm0.h ****   else
 762:Drivers/CMSIS/Include/core_cm0.h ****   {
 763:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 764:Drivers/CMSIS/Include/core_cm0.h ****   }
 765:Drivers/CMSIS/Include/core_cm0.h **** }
 766:Drivers/CMSIS/Include/core_cm0.h **** 
 767:Drivers/CMSIS/Include/core_cm0.h **** 
 768:Drivers/CMSIS/Include/core_cm0.h **** /**
 769:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Encode Priority
 770:Drivers/CMSIS/Include/core_cm0.h ****   \details Encodes the priority for an interrupt with the given priority group,
 771:Drivers/CMSIS/Include/core_cm0.h ****            preemptive priority value, and subpriority value.
 772:Drivers/CMSIS/Include/core_cm0.h ****            In case of a conflict between priority grouping and available
 773:Drivers/CMSIS/Include/core_cm0.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
 774:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]     PriorityGroup  Used priority group.
 775:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
 776:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]       SubPriority  Subpriority value (starting from 0).
 777:Drivers/CMSIS/Include/core_cm0.h ****   \return                        Encoded priority. Value can be used in the function \ref NVIC_SetP
 778:Drivers/CMSIS/Include/core_cm0.h ****  */
 779:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uin
 780:Drivers/CMSIS/Include/core_cm0.h **** {
 781:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used   
 782:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t PreemptPriorityBits;
 783:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t SubPriorityBits;
 784:Drivers/CMSIS/Include/core_cm0.h **** 
 785:Drivers/CMSIS/Include/core_cm0.h ****   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NV
 786:Drivers/CMSIS/Include/core_cm0.h ****   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint
 787:Drivers/CMSIS/Include/core_cm0.h **** 
 788:Drivers/CMSIS/Include/core_cm0.h ****   return (
 789:Drivers/CMSIS/Include/core_cm0.h ****            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits
 790:Drivers/CMSIS/Include/core_cm0.h ****            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 791:Drivers/CMSIS/Include/core_cm0.h ****          );
 792:Drivers/CMSIS/Include/core_cm0.h **** }
 793:Drivers/CMSIS/Include/core_cm0.h **** 
 794:Drivers/CMSIS/Include/core_cm0.h **** 
 795:Drivers/CMSIS/Include/core_cm0.h **** /**
 796:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Decode Priority
 797:Drivers/CMSIS/Include/core_cm0.h ****   \details Decodes an interrupt priority value with a given priority group to
 798:Drivers/CMSIS/Include/core_cm0.h ****            preemptive priority value and subpriority value.
 799:Drivers/CMSIS/Include/core_cm0.h ****            In case of a conflict between priority grouping and available
 800:Drivers/CMSIS/Include/core_cm0.h ****            priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
 801:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC
 802:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]     PriorityGroup  Used priority group.
 803:Drivers/CMSIS/Include/core_cm0.h ****   \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
 804:Drivers/CMSIS/Include/core_cm0.h ****   \param [out]     pSubPriority  Subpriority value (starting from 0).
 805:Drivers/CMSIS/Include/core_cm0.h ****  */
 806:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* cons
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 54


 807:Drivers/CMSIS/Include/core_cm0.h **** {
 808:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used   
 809:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t PreemptPriorityBits;
 810:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t SubPriorityBits;
 811:Drivers/CMSIS/Include/core_cm0.h **** 
 812:Drivers/CMSIS/Include/core_cm0.h ****   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NV
 813:Drivers/CMSIS/Include/core_cm0.h ****   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint
 814:Drivers/CMSIS/Include/core_cm0.h **** 
 815:Drivers/CMSIS/Include/core_cm0.h ****   *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1
 816:Drivers/CMSIS/Include/core_cm0.h ****   *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1
 817:Drivers/CMSIS/Include/core_cm0.h **** }
 818:Drivers/CMSIS/Include/core_cm0.h **** 
 819:Drivers/CMSIS/Include/core_cm0.h **** 
 820:Drivers/CMSIS/Include/core_cm0.h **** 
 821:Drivers/CMSIS/Include/core_cm0.h **** /**
 822:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Vector
 823:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets an interrupt vector in SRAM based interrupt vector table.
 824:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 825:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 826:Drivers/CMSIS/Include/core_cm0.h ****            Address 0 must be mapped to SRAM.
 827:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn      Interrupt number
 828:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   vector    Address of interrupt handler function
 829:Drivers/CMSIS/Include/core_cm0.h ****  */
 830:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
 831:Drivers/CMSIS/Include/core_cm0.h **** {
 832:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t *vectors = (uint32_t *)0x0U;
 833:Drivers/CMSIS/Include/core_cm0.h ****   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
 834:Drivers/CMSIS/Include/core_cm0.h **** }
 835:Drivers/CMSIS/Include/core_cm0.h **** 
 836:Drivers/CMSIS/Include/core_cm0.h **** 
 837:Drivers/CMSIS/Include/core_cm0.h **** /**
 838:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Vector
 839:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads an interrupt vector from interrupt vector table.
 840:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 841:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 842:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn      Interrupt number.
 843:Drivers/CMSIS/Include/core_cm0.h ****   \return                 Address of interrupt handler function
 844:Drivers/CMSIS/Include/core_cm0.h ****  */
 845:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
 846:Drivers/CMSIS/Include/core_cm0.h **** {
 847:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t *vectors = (uint32_t *)0x0U;
 848:Drivers/CMSIS/Include/core_cm0.h ****   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
 849:Drivers/CMSIS/Include/core_cm0.h **** }
 850:Drivers/CMSIS/Include/core_cm0.h **** 
 851:Drivers/CMSIS/Include/core_cm0.h **** 
 852:Drivers/CMSIS/Include/core_cm0.h **** /**
 853:Drivers/CMSIS/Include/core_cm0.h ****   \brief   System Reset
 854:Drivers/CMSIS/Include/core_cm0.h ****   \details Initiates a system reset request to reset the MCU.
 855:Drivers/CMSIS/Include/core_cm0.h ****  */
 856:Drivers/CMSIS/Include/core_cm0.h **** __NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
 1427              		.loc 4 856 34 view .LVU414
 1428              	.LBB94:
 857:Drivers/CMSIS/Include/core_cm0.h **** {
 858:Drivers/CMSIS/Include/core_cm0.h ****   __DSB();                                                          /* Ensure all outstanding memor
 1429              		.loc 4 858 3 view .LVU415
 1430              	.LBB95:
 1431              	.LBI95:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 55


 1432              		.file 5 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 56


  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 57


 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 144:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 145:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 158:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 159:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 160:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 168:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 58


 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 187:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 207:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 212:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 221:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 59


 228:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 229:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 233:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 243:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 247:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 249:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 266:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 269:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 270:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 271:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 272:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 279:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 281:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 282:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 283:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 60


 285:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 289:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 291:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 295:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 296:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 301:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 303:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 310:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 318:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 323:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 325:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 327:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 331:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 61


 342:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 345:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 352:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 358:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 366:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 370:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 375:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 378:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 382:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 384:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 386:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 390:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 391:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 62


 399:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 406:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 408:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 412:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 418:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 420:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 424:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 429:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 430:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 431:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 435:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 439:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 441:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 444:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 445:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 446:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 450:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 452:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 454:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 455:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 63


 456:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 457:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 461:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 463:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 465:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 472:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 484:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 486:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 487:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 491:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 493:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 495:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 496:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 499:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 503:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 505:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 507:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 508:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 509:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 510:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 64


 513:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 516:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 518:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 521:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 522:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 523:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 538:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 542:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 544:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 546:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 549:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 550:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 553:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 557:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 559:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 561:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 562:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 563:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 565:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 569:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 65


 570:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 571:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 573:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 574:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 575:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 579:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 583:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 589:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 592:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:Drivers/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 599:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 603:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 604:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 605:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 607:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 611:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 614:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 616:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 620:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 624:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 625:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 626:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 66


 627:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 628:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 629:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 634:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 637:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 639:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 644:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 646:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 647:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 649:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 651:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 655:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 658:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 660:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 664:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 666:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 667:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 668:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 669:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 671:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 676:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 67


 684:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 686:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 690:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 691:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 692:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 693:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 695:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 699:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 702:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 704:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 708:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 712:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 713:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 714:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 715:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 716:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 717:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 725:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 727:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 732:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 734:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 735:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 736:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 737:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 739:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 68


 741:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 743:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 746:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 748:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 752:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 754:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 755:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 756:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 757:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 760:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 761:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 762:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 766:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 768:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 776:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 778:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 781:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 782:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 784:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 785:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 787:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 788:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 69


 798:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:Drivers/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 802:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 804:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 805:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 807:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 808:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 809:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 810:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 817:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 818:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 819:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 827:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 831:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 832:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 833:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 836:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 838:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 839:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 842:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 844:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 845:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 846:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 850:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 853:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 854:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 70


 855:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 857:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 859:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 860:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 861:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 866:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 868:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 870:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 871:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 872:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 873:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 1433              		.loc 5 877 27 view .LVU416
 1434              	.LBB96:
 878:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 879:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 1435              		.loc 5 879 3 view .LVU417
 1436              		.syntax divided
 1437              	@ 879 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1438 0134 BFF34F8F 		dsb 0xF
 1439              	@ 0 "" 2
 1440              		.thumb
 1441              		.syntax unified
 1442              	.LBE96:
 1443              	.LBE95:
 859:Drivers/CMSIS/Include/core_cm0.h ****                                                                        buffered write are completed
 860:Drivers/CMSIS/Include/core_cm0.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 1444              		.loc 4 860 3 view .LVU418
 1445              		.loc 4 860 15 is_stmt 0 view .LVU419
 1446 0138 0E4B     		ldr	r3, .L72+28
 1447 013a 0F4A     		ldr	r2, .L72+32
 1448 013c DA60     		str	r2, [r3, #12]
 861:Drivers/CMSIS/Include/core_cm0.h ****                  SCB_AIRCR_SYSRESETREQ_Msk);
 862:Drivers/CMSIS/Include/core_cm0.h ****   __DSB();                                                          /* Ensure completion of memory 
 1449              		.loc 4 862 3 is_stmt 1 view .LVU420
 1450              	.LBB97:
 1451              	.LBI97:
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1452              		.loc 5 877 27 view .LVU421
 1453              	.LBB98:
 1454              		.loc 5 879 3 view .LVU422
 1455              		.syntax divided
 1456              	@ 879 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1457 013e BFF34F8F 		dsb 0xF
 1458              	@ 0 "" 2
 1459              		.thumb
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 71


 1460              		.syntax unified
 1461              	.L66:
 1462              	.LBE98:
 1463              	.LBE97:
 863:Drivers/CMSIS/Include/core_cm0.h **** 
 864:Drivers/CMSIS/Include/core_cm0.h ****   for(;;)                                                           /* wait until reset */
 1464              		.loc 4 864 3 view .LVU423
 865:Drivers/CMSIS/Include/core_cm0.h ****   {
 866:Drivers/CMSIS/Include/core_cm0.h ****     __NOP();
 1465              		.loc 4 866 5 view .LVU424
 1466              		.syntax divided
 1467              	@ 866 "Drivers/CMSIS/Include/core_cm0.h" 1
 1468 0142 C046     		nop
 1469              	@ 0 "" 2
 864:Drivers/CMSIS/Include/core_cm0.h ****   {
 1470              		.loc 4 864 3 view .LVU425
 1471              		.thumb
 1472              		.syntax unified
 1473 0144 FDE7     		b	.L66
 1474              	.LVL150:
 1475              	.L70:
 864:Drivers/CMSIS/Include/core_cm0.h ****   {
 1476              		.loc 4 864 3 is_stmt 0 view .LVU426
 1477              	.LBE94:
 1478              	.LBE93:
 1479              	.LBB99:
 1480              	.LBB92:
 107:Inc/random_flash_interface.h **** 
 1481              		.loc 3 107 32 view .LVU427
 1482 0146 FFF7FEFF 		bl	eeprom_buffer_flush
 1483              	.LVL151:
 109:Inc/random_flash_interface.h ****             _validEEPROM = true;
 1484              		.loc 3 109 26 view .LVU428
 1485 014a 01AB     		add	r3, sp, #4
 1486              	.LVL152:
 109:Inc/random_flash_interface.h ****             _validEEPROM = true;
 1487              		.loc 3 109 26 view .LVU429
 1488 014c 0022     		movs	r2, #0
 1489 014e 5A70     		strb	r2, [r3, #1]
 110:Inc/random_flash_interface.h ****         } else
 1490              		.loc 3 110 26 view .LVU430
 1491 0150 0132     		adds	r2, r2, #1
 1492 0152 DA70     		strb	r2, [r3, #3]
 1493 0154 E3E7     		b	.L58
 1494              	.L73:
 1495 0156 C046     		.align	2
 1496              	.L72:
 1497 0158 00000000 		.word	.LANCHOR1
 1498 015c 00000000 		.word	.LANCHOR0
 1499 0160 00000000 		.word	htim3
 1500 0164 00000000 		.word	i2cDataRx
 1501 0168 00000000 		.word	hi2c1
 1502 016c 00000000 		.word	htim14
 1503 0170 00000000 		.word	.LANCHOR2
 1504 0174 00ED00E0 		.word	-536810240
 1505 0178 0400FA05 		.word	100270084
 1506              	.LBE92:
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 72


 1507              	.LBE99:
 1508              		.cfi_endproc
 1509              	.LFE62:
 1510              		.fnend
 1512              		.section	.text._GLOBAL__sub_I_motor,"ax",%progbits
 1513              		.align	1
 1514              		.syntax unified
 1515              		.code	16
 1516              		.thumb_func
 1518              	_GLOBAL__sub_I_motor:
 1519              		.fnstart
 1520              	.LFB68:
 1521              		.loc 1 237 1 is_stmt 1 view -0
 1522              		.cfi_startproc
 1523              		@ args = 0, pretend = 0, frame = 0
 1524              		@ frame_needed = 0, uses_anonymous_args = 0
 1525 0000 10B5     		push	{r4, lr}
 1526              	.LCFI7:
 1527              		.cfi_def_cfa_offset 8
 1528              		.cfi_offset 4, -8
 1529              		.cfi_offset 14, -4
 1530              		.loc 1 237 1 is_stmt 0 view .LVU432
 1531 0002 0249     		ldr	r1, .L75
 1532 0004 0120     		movs	r0, #1
 1533 0006 FFF7FEFF 		bl	_Z41__static_initialization_and_destruction_0ii
 1534              	.LVL153:
 1535              		@ sp needed
 1536 000a 10BD     		pop	{r4, pc}
 1537              	.L76:
 1538              		.align	2
 1539              	.L75:
 1540 000c FFFF0000 		.word	65535
 1541              		.cfi_endproc
 1542              	.LFE68:
 1543              		.cantunwind
 1544              		.fnend
 1546              		.section	.init_array,"aw",%init_array
 1547              		.align	2
 1548 0000 00000000 		.word	_GLOBAL__sub_I_motor(target1)
 1549              		.global	boardConfig
 1550              		.global	motor
 1551              		.section	.rodata
 1552              		.align	2
 1553              		.set	.LANCHOR2,. + 0
 1554              	.LC0:
 1555 0000 01       		.byte	1
 1556 0001 0C       		.byte	12
 1557 0002 0000     		.space	2
 1558 0004 0000B442 		.word	1119092736
 1559 0008 0000003F 		.word	1056964608
 1560 000c 00000000 		.word	0
 1561 0010 FA00     		.short	250
 1562 0012 B80B     		.short	3000
 1563 0014 00000000 		.word	0
 1564 0018 00003443 		.word	1127481344
 1565 001c 00002041 		.word	1092616192
 1566 0020 00000000 		.word	0
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 73


 1567 0024 00000000 		.word	0
 1568 0028 00004842 		.word	1112014848
 1569 002c 00       		.byte	0
 1570 002d 000000   		.space	3
 1571              		.section	.bss.boardConfig,"aw",%nobits
 1572              		.align	2
 1573              		.set	.LANCHOR1,. + 0
 1576              	boardConfig:
 1577 0000 00000000 		.space	48
 1577      00000000 
 1577      00000000 
 1577      00000000 
 1577      00000000 
 1578              		.section	.bss.motor,"aw",%nobits
 1579              		.align	2
 1580              		.set	.LANCHOR0,. + 0
 1583              	motor:
 1584 0000 00000000 		.space	88
 1584      00000000 
 1584      00000000 
 1584      00000000 
 1584      00000000 
 1585              		.text
 1586              	.Letext0:
 1587              		.file 6 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\\
 1588              		.file 7 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\\
 1589              		.file 8 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\\
 1590              		.file 9 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\lib\\gcc\\arm-none-eabi\
 1591              		.file 10 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\
 1592              		.file 11 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\
 1593              		.file 12 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\
 1594              		.file 13 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\
 1595              		.file 14 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f030x6.h"
 1596              		.file 15 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h"
 1597              		.file 16 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h"
 1598              		.file 17 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h"
 1599              		.file 18 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_adc.h"
 1600              		.file 19 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_i2c.h"
 1601              		.file 20 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim.h"
 1602              		.file 21 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h"
 1603              		.file 22 "Inc/adc.h"
 1604              		.file 23 "Inc/i2c.h"
 1605              		.file 24 "Inc/tim.h"
 1606              		.file 25 "Inc/configurations.h"
 1607              		.file 26 "Inc/random_flash_utils.h"
 1608              		.file 27 "<built-in>"
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 74


DEFINED SYMBOLS
                            *ABS*:00000000 user.cpp
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:18     .text._Z41__static_initialization_and_destruction_0ii:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:23     .text._Z41__static_initialization_and_destruction_0ii:00000000 _Z41__static_initialization_and_destruction_0ii
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:65     .text._Z41__static_initialization_and_destruction_0ii:00000014 $d
.ARM.exidx.text._Z41__static_initialization_and_destruction_0ii:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:74     .text.HAL_I2C_SlaveRxCpltCallback:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:80     .text.HAL_I2C_SlaveRxCpltCallback:00000000 HAL_I2C_SlaveRxCpltCallback
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:132    .rodata.HAL_I2C_SlaveRxCpltCallback:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:759    .text.HAL_I2C_SlaveRxCpltCallback:000001dc $d
.ARM.exidx.text.HAL_I2C_SlaveRxCpltCallback:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:781    .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:787    .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:912    .text.HAL_TIM_PeriodElapsedCallback:00000088 $d
.ARM.exidx.text.HAL_TIM_PeriodElapsedCallback:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:921    .text._ZN6EEPROM3putI8Config_tEERKT_iS4_:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:927    .text._ZN6EEPROM3putI8Config_tEERKT_iS4_:00000000 _ZN6EEPROM3putI8Config_tEERKT_iS4_
.ARM.exidx.text._ZN6EEPROM3putI8Config_tEERKT_iS4_:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1058   .text.Main:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1064   .text.Main:00000000 Main
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1497   .text.Main:00000158 $d
             .ARM.exidx.text.Main:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1513   .text._GLOBAL__sub_I_motor:00000000 $t
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1518   .text._GLOBAL__sub_I_motor:00000000 _GLOBAL__sub_I_motor
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1540   .text._GLOBAL__sub_I_motor:0000000c $d
.ARM.exidx.text._GLOBAL__sub_I_motor:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1547   .init_array:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1576   .bss.boardConfig:00000000 boardConfig
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1583   .bss.motor:00000000 motor
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1552   .rodata:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1572   .bss.boardConfig:00000000 $d
C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s:1579   .bss.motor:00000000 $d

UNDEFINED SYMBOLS
_ZN5Motor9SetEnableEb
HAL_I2C_Slave_Transmit
HAL_I2C_Slave_Receive_IT
_ZN5Motor14SetTorqueLimitEf
i2cDataRx
i2cDataTx
hi2c1
__aeabi_unwind_cpp_pr0
__aeabi_fsub
__aeabi_ui2f
__aeabi_fmul
__aeabi_fdiv
__aeabi_fadd
__aeabi_f2iz
HAL_ADC_Start_DMA
_ZN5Motor13CalcDceOutputEff
_ZN5Motor6SetPwmEs
adcData
hadc
eeprom_buffer_fill
eeprom_buffered_write_byte
eeprom_buffer_flush
eeprom_buffered_read_byte
ARM GAS  C:\Users\ADMINI~1\AppData\Local\Temp\cclNwmIC.s 			page 75


HAL_TIM_PWM_Start
MY_I2C1_Init
HAL_Delay
HAL_TIM_Base_Start_IT
htim3
htim14
